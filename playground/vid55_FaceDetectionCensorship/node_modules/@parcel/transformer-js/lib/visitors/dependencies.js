"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var types = _interopRequireWildcard(require("@babel/types"));

var _traverse = _interopRequireDefault(require("@babel/traverse"));

var _utils = require("@parcel/utils");

var _utils2 = require("./utils");

var _assert = _interopRequireDefault(require("assert"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { keys.push.apply(keys, Object.getOwnPropertySymbols(object)); } if (enumerableOnly) keys = keys.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const serviceWorkerPattern = ['navigator', 'serviceWorker', 'register'];
var _default = {
  ImportDeclaration(node, {
    asset
  }) {
    asset.meta.isES6Module = true;
    addDependency(asset, node.source);
  },

  ExportNamedDeclaration(node, {
    asset
  }) {
    asset.meta.isES6Module = true;

    if (node.source) {
      addDependency(asset, node.source);
    }
  },

  ExportAllDeclaration(node, {
    asset
  }) {
    asset.meta.isES6Module = true;
    addDependency(asset, node.source);
  },

  ExportDefaultDeclaration(node, {
    asset
  }) {
    asset.meta.isES6Module = true;
  },

  CallExpression(node, {
    asset
  }, ancestors) {
    let {
      callee,
      arguments: args
    } = node;
    let isRequire = types.isIdentifier(callee) && callee.name === 'require' && args.length === 1 && types.isStringLiteral(args[0]) && !(0, _utils2.hasBinding)(ancestors, 'require') && !isInFalsyBranch(ancestors);

    if (isRequire) {
      let isOptional = ancestors.some(a => types.isTryStatement(a)) || undefined;
      addDependency(asset, args[0], {
        isOptional
      });
      return;
    }

    let isDynamicImport = callee.type === 'Import' && args.length === 1 && types.isStringLiteral(args[0]);

    if (isDynamicImport) {
      // Ignore dynamic imports of fully specified urls
      if ((0, _utils.isURL)(args[0].value)) {
        return;
      }

      addDependency(asset, args[0], {
        isAsync: true
      });
      node.callee = types.identifier('require');
      (0, _assert.default)(asset.ast);
      asset.ast.isDirty = true;
      return;
    }

    const isRegisterServiceWorker = types.isStringLiteral(args[0]) && types.matchesPattern(callee, serviceWorkerPattern) && !(0, _utils2.hasBinding)(ancestors, 'navigator') && !isInFalsyBranch(ancestors);

    if (isRegisterServiceWorker) {
      // Treat service workers as an entry point so filenames remain consistent across builds.
      // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#avoid_changing_the_url_of_your_service_worker_script
      addURLDependency(asset, args[0], {
        isEntry: true,
        env: {
          context: 'service-worker'
        }
      });
    }
  },

  NewExpression(node, {
    asset,
    options
  }, ancestors) {
    let {
      callee,
      arguments: args
    } = node;
    let isWebWorker = callee.type === 'Identifier' && (callee.name === 'Worker' || callee.name === 'SharedWorker') && !(0, _utils2.hasBinding)(ancestors, callee.name) && !isInFalsyBranch(ancestors) && types.isStringLiteral(args[0]) && (args.length === 1 || args.length === 2);

    if (isWebWorker) {
      let isModule = false;

      if (types.isObjectExpression(args[1])) {
        let prop = args[1].properties.find(v => types.isIdentifier(v.key, {
          name: 'type'
        }));
        if (prop && types.isStringLiteral(prop.value)) isModule = prop.value.value === 'module';
      }

      addURLDependency(asset, args[0], {
        env: {
          context: 'web-worker',
          outputFormat: isModule && options.scopeHoist ? 'esmodule' : undefined
        }
      });
    }
  }

};
exports.default = _default;

function isInFalsyBranch(ancestors) {
  // Check if any ancestors are if statements
  return ancestors.some((node, index) => {
    if (types.isIfStatement(node)) {
      let res = evaluateExpression(node.test);

      if (res && res.confident) {
        // If the test is truthy, exclude the dep if it is in the alternate branch.
        // If the test if falsy, exclude the dep if it is in the consequent branch.
        let child = ancestors[index + 1];
        return res.value ? child === node.alternate : child === node.consequent;
      }
    }
  });
}

function evaluateExpression(node) {
  // Wrap the node in a standalone program so we can traverse it
  node = types.file(types.program([types.expressionStatement(node)])); // Find the first expression and evaluate it.

  let res = null;
  (0, _traverse.default)(node, {
    Expression(path) {
      res = path.evaluate();
      path.stop();
    }

  });
  return res;
}

function addDependency(asset, node, opts = {}) {
  // If this came from an inline <script> tag, throw an error.
  // TODO: run JSPackager on inline script tags.
  // let inlineHTML =
  //   asset.options.rendition && asset.options.rendition.inlineHTML;
  // if (inlineHTML) {
  //   let err = new Error(
  //     'Imports and requires are not supported inside inline <script> tags yet.'
  //   );
  //   err.loc = node.loc && node.loc.start;
  //   throw err;
  // }
  asset.addDependency(_objectSpread({
    moduleSpecifier: node.value,
    loc: node.loc && node.loc.start
  }, opts));
}

function addURLDependency(asset, node, opts = {}) {
  node.value = asset.addURLDependency(node.value, _objectSpread({
    loc: node.loc && node.loc.start
  }, opts));
  (0, _assert.default)(asset.ast);
  asset.ast.isDirty = true;
}