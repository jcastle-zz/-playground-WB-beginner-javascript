"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _path = _interopRequireDefault(require("path"));

var types = _interopRequireWildcard(require("@babel/types"));

var _utils = require("./utils");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const VARS = {
  process: () => ({
    code: 'var process = require("process");',
    deps: ['process']
  }),
  global: () => ({
    code: `var global = arguments[${
    /*asset.options.scopeHoist ? 0 : */
    3}];`
  }),
  __dirname: asset => ({
    code: `var __dirname = ${JSON.stringify(_path.default.dirname(asset.filePath))};`
  }),
  __filename: asset => ({
    code: `var __filename = ${JSON.stringify(asset.filePath)};`
  }),
  Buffer: () => ({
    code: 'var Buffer = require("buffer").Buffer;',
    deps: ['buffer']
  }),
  // Prevent AMD defines from working when loading UMD bundles.
  // Ideally the CommonJS check would come before the AMD check, but many
  // existing modules do the checks the opposite way leading to modules
  // not exporting anything to Parcel.
  define: () => ({
    code: 'var define;'
  })
};
var _default = {
  Identifier(node, asset, ancestors) {
    let parent = ancestors[ancestors.length - 2];

    if (VARS.hasOwnProperty(node.name) && !(0, _nullthrows.default)(asset.meta.globals).has(node.name) && types.isReferenced(node, parent) && !(0, _utils.hasBinding)(ancestors, node.name)) {
      (0, _nullthrows.default)(asset.meta.globals).set(node.name, VARS[node.name](asset));
    }
  },

  Declaration(node, asset, ancestors) {
    // If there is a global declaration of one of the variables, remove our declaration
    let identifiers = types.getBindingIdentifiers(node);

    for (let id in identifiers) {
      if (VARS.hasOwnProperty(id) && !inScope(ancestors)) {
        // Don't delete entirely, so we don't add it again when the declaration is referenced
        (0, _nullthrows.default)(asset.meta.globals).set(id, null);
      }
    }
  },

  Program: {
    exit(node, asset) {
      // Add dependencies at the end so that items that were deleted later don't leave
      // their dependencies around.
      for (let g of (0, _nullthrows.default)(asset.meta.globals).values()) {
        if (g && g.deps) {
          for (let dep of g.deps) {
            asset.addDependency({
              moduleSpecifier: dep
            });
          }
        }
      }
    }

  }
};
exports.default = _default;

function inScope(ancestors) {
  for (let i = ancestors.length - 2; i >= 0; i--) {
    if (types.isScope(ancestors[i]) && !types.isProgram(ancestors[i])) {
      return true;
    }
  }

  return false;
}