"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._addToInstallQueue = _addToInstallQueue;
exports.installPackage = installPackage;

var _logger = _interopRequireDefault(require("@parcel/logger"));

var _path = _interopRequireDefault(require("path"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _workers = _interopRequireDefault(require("@parcel/workers"));

var _utils = require("@parcel/utils");

var _Npm = require("./Npm");

var _Yarn = require("./Yarn");

var _validateModuleSpecifiers = _interopRequireDefault(require("./validateModuleSpecifiers"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function install(fs, modules, filepath, options = {}) {
  let {
    installPeers = true,
    saveDev = true,
    packageInstaller
  } = options;

  _logger.default.progress(`Installing ${modules.join(', ')}...`);

  let packagePath = await (0, _utils.resolveConfig)(fs, filepath, ['package.json']);
  let cwd = packagePath ? _path.default.dirname(packagePath) : fs.cwd();

  if (!packageInstaller) {
    packageInstaller = await determinePackageInstaller(fs, filepath);
  }

  try {
    await packageInstaller.install({
      modules,
      saveDev,
      cwd,
      packagePath,
      fs
    });
  } catch (err) {
    throw new Error(`Failed to install ${modules.join(', ')}.`);
  }

  if (installPeers) {
    await Promise.all(modules.map(m => installPeerDependencies(fs, filepath, m, options)));
  }
}

async function installPeerDependencies(fs, filepath, name, options) {
  let basedir = _path.default.dirname(filepath);

  const {
    resolved
  } = await (0, _utils.resolve)(fs, name, {
    basedir
  });
  const pkg = (0, _nullthrows.default)((await (0, _utils.loadConfig)(fs, resolved, ['package.json']))).config;
  const peers = pkg.peerDependencies || {};
  const modules = [];

  for (const peer in peers) {
    modules.push(`${peer}@${peers[peer]}`);
  }

  if (modules.length) {
    await install(fs, modules, filepath, Object.assign({}, options, {
      installPeers: false
    }));
  }
}

async function determinePackageInstaller(fs, filepath) {
  let configFile = await (0, _utils.resolveConfig)(fs, filepath, ['yarn.lock', 'package-lock.json']);
  let hasYarn = await _Yarn.Yarn.exists(); // If Yarn isn't available, or there is a package-lock.json file, use npm.

  let configName = configFile && _path.default.basename(configFile);

  if (!hasYarn || configName === 'package-lock.json') {
    return new _Npm.Npm();
  }

  return new _Yarn.Yarn();
}

let queue = new _utils.PromiseQueue({
  maxConcurrent: 1
});
let modulesInstalling = new Set(); // Exported so that it may be invoked from the worker api below.
// Do not call this directly! This can result in concurrent package installations
// across multiple instances of the package manager.

function _addToInstallQueue(fs, modules, filePath, options) {
  modules = (0, _validateModuleSpecifiers.default)(modules); // Wrap PromiseQueue and track modules that are currently installing.
  // If a request comes in for a module that is currently installing, don't bother
  // enqueuing it.
  //
  // "module" means anything acceptable to yarn/npm. This can include a semver range,
  // e.g. "lodash@^3.2.0" -- we don't dedupe unless this entire string is an exact match.

  let modulesToInstall = modules.filter(m => !modulesInstalling.has(m));

  if (modulesToInstall.length) {
    for (let m of modulesToInstall) {
      modulesInstalling.add(m);
    }

    queue.add(() => install(fs, modulesToInstall, filePath, options).then(() => {
      for (let m of modulesToInstall) {
        modulesInstalling.delete(m);
      }
    })).then(() => {}, () => {});
  }

  return queue.run();
}

function installPackage(fs, modules, filePath, options) {
  if (_workers.default.isWorker()) {
    let workerApi = _workers.default.getWorkerApi();

    return workerApi.callMaster({
      location: __filename,
      args: [fs, modules, filePath, options],
      method: '_addToInstallQueue'
    });
  }

  return _addToInstallQueue(fs, modules, filePath, options);
}