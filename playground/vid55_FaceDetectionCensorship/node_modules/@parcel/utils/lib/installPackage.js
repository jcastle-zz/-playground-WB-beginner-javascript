"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._addToInstallQueue = _addToInstallQueue;
exports.default = installPackage;

var _workers = _interopRequireDefault(require("@parcel/workers"));

var _logger = _interopRequireDefault(require("@parcel/logger"));

var _path = _interopRequireDefault(require("path"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _config = require("./config");

var _Npm = _interopRequireDefault(require("./Npm"));

var _PromiseQueue = _interopRequireDefault(require("./PromiseQueue"));

var _resolve = _interopRequireDefault(require("./resolve"));

var _Yarn = _interopRequireDefault(require("./Yarn"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function install(modules, filepath, options = {}) {
  let {
    installPeers = true,
    saveDev = true,
    packageManager: packageManagerName
  } = options;

  _logger.default.progress(`Installing ${modules.join(', ')}...`);

  let packageLocation = await (0, _config.resolveConfig)(filepath, ['package.json']);
  let cwd = packageLocation ? _path.default.dirname(packageLocation) : process.cwd();

  if (!packageManagerName) {
    packageManagerName = await determinePackageManager(filepath);
  }

  let packageManager = packageManagerName === 'npm' ? new _Npm.default({
    cwd,
    packageLocation
  }) : new _Yarn.default({
    cwd
  });

  try {
    await packageManager.install(modules, saveDev);
  } catch (err) {
    throw new Error(`Failed to install ${modules.join(', ')}.`);
  }

  if (installPeers) {
    await Promise.all(modules.map(m => installPeerDependencies(filepath, m, options)));
  }
}

async function installPeerDependencies(filepath, name, options) {
  let basedir = _path.default.dirname(filepath);

  const [resolved] = await (0, _resolve.default)(name, {
    basedir
  });
  const pkg = (0, _nullthrows.default)((await (0, _config.loadConfig)(resolved, ['package.json']))).config;
  const peers = pkg.peerDependencies || {};
  const modules = [];

  for (const peer in peers) {
    modules.push(`${peer}@${peers[peer]}`);
  }

  if (modules.length) {
    await install(modules, filepath, Object.assign({}, options, {
      installPeers: false
    }));
  }
}

async function determinePackageManager(filepath) {
  let configFile = await (0, _config.resolveConfig)(filepath, ['yarn.lock', 'package-lock.json']);
  let hasYarn = await _Yarn.default.exists(); // If Yarn isn't available, or there is a package-lock.json file, use npm.

  let configName = configFile && _path.default.basename(configFile);

  if (!hasYarn || configName === 'package-lock.json') {
    return 'npm';
  }

  return 'yarn';
}

let queue = new _PromiseQueue.default({
  maxConcurrent: 1
});
let modulesInstalling = new Set(); // Exported so that it may be invoked from the worker api below.
// Do not call this directly! This can result in concurrent package installations
// across multiple instances of the package manager.

function _addToInstallQueue(modules, filePath, options) {
  // Wrap PromiseQueue and track modules that are currently installing.
  // If a request comes in for a module that is currently installing, don't bother
  // enqueuing it.
  //
  // "module" means anything acceptable to yarn/npm. This can include a semver range,
  // e.g. "lodash@^3.2.0" -- we don't dedupe unless this entire string is an exact match.
  let modulesToInstall = modules.filter(m => !modulesInstalling.has(m));

  if (modulesToInstall.length) {
    for (let m of modulesToInstall) {
      modulesInstalling.add(m);
    }

    queue.add(() => install(modulesToInstall, filePath, options).then(() => {
      for (let m of modulesToInstall) {
        modulesInstalling.delete(m);
      }
    }));
  }

  return queue.run();
}

function installPackage(...args) {
  return _workers.default.callMaster({
    location: __filename,
    args,
    method: '_addToInstallQueue'
  });
}