"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = dumpGraphToGraphViz;

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _graphviz = _interopRequireDefault(require("graphviz"));

var _tempy = _interopRequireDefault(require("tempy"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const COLORS = {
  root: 'gray',
  asset: 'green',
  dependency: 'orange',
  transformer_request: 'cyan',
  file: 'gray',
  default: 'white'
};

async function dumpGraphToGraphViz(graph, name) {
  let g = _graphviz.default.digraph('G');

  let nodes = Array.from(graph.nodes.values());

  for (let node of nodes) {
    let n = g.addNode(node.id); // $FlowFixMe default is fine. Not every type needs to be in the map.

    n.set('color', COLORS[node.type || 'default']);
    n.set('shape', 'box');
    n.set('style', 'filled');
    let label = `${node.type || 'No Type'}: `;

    if (node.type === 'dependency') {
      label += node.value.moduleSpecifier;
      let parts = [];
      if (node.value.isEntry) parts.push('entry');
      if (node.value.isAsync) parts.push('async');
      if (node.value.isOptional) parts.push('optional');
      if (parts.length) label += ' (' + parts.join(', ') + ')';
      if (node.value.env) label += ` (${getEnvDescription(node.value.env)})`;
    } else if (node.type === 'asset' || node.type === 'asset_reference') {
      label += _path.default.basename(node.value.filePath) + '#' + node.value.type;
    } else if (node.type === 'file') {
      label += _path.default.basename(node.value.filePath);
    } else if (node.type === 'transformer_request') {
      label += _path.default.basename(node.value.filePath) + ` (${getEnvDescription(node.value.env)})`;
    } else if (node.type === 'bundle') {
      let rootAssets = node.value.assetGraph.getNodesConnectedFrom((0, _nullthrows.default)(node.value.assetGraph.getRootNode()));
      label += rootAssets.map(asset => {
        (0, _assert.default)(asset.type === 'asset');
        let parts = asset.value.filePath.split(_path.default.sep);
        let index = parts.lastIndexOf('node_modules');

        if (index >= 0) {
          return parts[index + 1];
        }

        return _path.default.basename(asset.value.filePath);
      }).join(', ');
    } else {
      // label += node.id;
      label = node.type;
    }

    n.set('label', label);
  }

  for (let edge of graph.edges) {
    g.addEdge(edge.from, edge.to);
  }

  let tmp = _tempy.default.file({
    name: `${name}.png`
  });

  await g.output('png', tmp);
  console.log(`open ${tmp}`); // eslint-disable-line no-console
}

function getEnvDescription(env) {
  let description = '';

  if (env.engines.browsers) {
    description = `${env.context}: ${env.engines.browsers.join(', ')}`;
  } else if (env.engines.node) {
    description = `node: ${env.engines.node}`;
  }

  return description;
}