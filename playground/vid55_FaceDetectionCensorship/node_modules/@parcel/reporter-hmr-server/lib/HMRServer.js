"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _ws = _interopRequireDefault(require("ws"));

var _ansiHtml = _interopRequireDefault(require("ansi-html"));

var _utils = require("@parcel/utils");

var _logger = _interopRequireDefault(require("@parcel/logger"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class HMRServer {
  constructor(options) {
    _defineProperty(this, "server", void 0);

    _defineProperty(this, "wss", void 0);

    _defineProperty(this, "unresolvedError", null);

    _defineProperty(this, "options", void 0);

    this.options = options;
  }

  async start() {
    await new Promise(async resolve => {
      if (!this.options.https) {
        this.server = _http.default.createServer();
      } else if (this.options.https === true) {
        this.server = _https.default.createServer((await (0, _utils.generateCertificate)(this.options.outputFS, this.options.cacheDir)));
      } else {
        this.server = _https.default.createServer((await (0, _utils.getCertificate)(this.options.inputFS, this.options.https)));
      }

      let websocketOptions = {
        server: this.server
        /*verifyClient: info => {
          if (!this.options.host) return true;
           let originator = new URL(info.origin);
          return this.options.host === originator.hostname;
        }*/

      };
      this.wss = new _ws.default.Server(websocketOptions);
      this.server.listen(this.options.port, this.options.host, resolve);
    });
    this.wss.on('connection', ws => {
      ws.onerror = this.handleSocketError;

      if (this.unresolvedError) {
        ws.send(JSON.stringify(this.unresolvedError));
      }
    });
    this.wss.on('error', this.handleSocketError);
    return this.wss._server.address().port;
  }

  stop() {
    this.wss.close();
    this.server.close();
  }

  emitError(err) {
    let {
      message,
      stack
    } = (0, _utils.prettyError)(err); // store the most recent error so we can notify new connections
    // and so we can broadcast when the error is resolved

    this.unresolvedError = {
      type: 'error',
      ansiError: {
        message,
        stack
      },
      htmlError: {
        message: (0, _ansiHtml.default)(message),
        stack: (0, _ansiHtml.default)(stack)
      }
    };
    this.broadcast(this.unresolvedError);
  }

  async emitUpdate(event) {
    this.unresolvedError = null;
    let changedAssets = Array.from(event.changedAssets.values()).filter(asset => asset.env.context === 'browser');
    if (changedAssets.length === 0) return;
    let assets = await Promise.all(changedAssets.map(async asset => {
      let dependencies = event.bundleGraph.getDependencies(asset);
      let deps = {};

      for (let dep of dependencies) {
        let resolved = event.bundleGraph.getDependencyResolution(dep);

        if (resolved) {
          deps[dep.moduleSpecifier] = resolved.id;
        }
      }

      return {
        id: asset.id,
        type: asset.type,
        output: await asset.getCode(),
        envHash: (0, _utils.md5FromObject)(asset.env),
        deps
      };
    }));
    this.broadcast({
      type: 'update',
      assets: assets
    });
  }

  handleSocketError(err) {
    if (err.code === 'ECONNRESET') {
      // This gets triggered on page refresh, ignore this
      return;
    }

    _logger.default.warn(err);
  }

  broadcast(msg) {
    const json = JSON.stringify(msg);

    for (let ws of this.wss.clients) {
      ws.send(json);
    }
  }

}

exports.default = HMRServer;