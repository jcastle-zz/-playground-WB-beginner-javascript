"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _plugin = require("@parcel/plugin");

var _fs = _interopRequireDefault(require("fs"));

var _scopeHoisting = require("@parcel/scope-hoisting");

var _sourceMap = _interopRequireDefault(require("@parcel/source-map"));

var _utils = require("@parcel/utils");

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PRELUDE = _fs.default.readFileSync(_path.default.join(__dirname, 'prelude.js'), 'utf8').trim().replace(/;$/, '');

var _default = new _plugin.Packager({
  async package({
    bundle,
    bundleGraph,
    getSourceMapReference,
    options
  }) {
    // If scope hoisting is enabled, we use a different code path.
    if (options.scopeHoist) {
      let ast = await (0, _scopeHoisting.concat)(bundle, bundleGraph);
      ast = (0, _scopeHoisting.link)({
        bundle,
        bundleGraph,
        ast,
        options
      });
      return (0, _scopeHoisting.generate)(bundleGraph, bundle, ast, options);
    }

    if (bundle.env.outputFormat === 'esmodule') {
      throw new Error(`esmodule output is not supported without scope hoisting.`);
    } // For development, we just concatenate all of the code together
    // rather then enabling scope hoisting, which would be too slow.


    let codeQueue = new _utils.PromiseQueue({
      maxConcurrent: 32
    });
    let mapQueue = new _utils.PromiseQueue({
      maxConcurrent: 32
    });
    bundle.traverse(node => {
      if (node.type === 'asset') {
        codeQueue.add(() => node.value.getCode());
        mapQueue.add(() => node.value.getMap());
      }
    });
    let [code, maps] = await Promise.all([codeQueue.run(), mapQueue.run()]);
    let assets = '';
    let i = 0;
    let first = true;
    let map = new _sourceMap.default();
    let lineOffset = (0, _utils.countLines)(PRELUDE);
    let stubsWritten = new Set();
    bundle.traverse(node => {
      let wrapped = first ? '' : ',';

      if (node.type === 'dependency') {
        let resolved = bundleGraph.getDependencyResolution(node.value);

        if (resolved && resolved.type !== 'js' && !stubsWritten.has(resolved.id)) {
          // if this is a reference to another javascript asset, we should not include
          // its output, as its contents should already be loaded.
          (0, _assert.default)(!bundle.hasAsset(resolved));
          wrapped += JSON.stringify(resolved.id) + ':[function() {},{}]';
        } else {
          return;
        }
      }

      if (node.type === 'asset') {
        let asset = node.value;
        (0, _assert.default)(asset.type === 'js', 'all assets in a js bundle must be js assets');
        let deps = {};
        let dependencies = bundleGraph.getDependencies(asset);

        for (let dep of dependencies) {
          let resolved = bundleGraph.getDependencyResolution(dep);

          if (resolved) {
            deps[dep.moduleSpecifier] = resolved.id;
          }
        }

        let output = code[i] || '';
        wrapped += JSON.stringify(asset.id) + ':[function(require,module,exports) {\n' + output + '\n},';
        wrapped += JSON.stringify(deps);
        wrapped += ']';

        if (options.sourceMaps) {
          var _maps$i;

          let assetMap = (_maps$i = maps[i]) !== null && _maps$i !== void 0 ? _maps$i : _sourceMap.default.generateEmptyMap(_path.default.relative(options.projectRoot, asset.filePath).replace(/\\+/g, '/'), output);
          map.addMap(assetMap, lineOffset);
          lineOffset += (0, _utils.countLines)(output) + 1;
        }

        i++;
      }

      assets += wrapped;
      first = false;
    });
    let entries = bundle.getEntryAssets();
    let interpreter = null;
    let isEntry = !bundleGraph.hasParentBundleOfType(bundle, 'js');

    if (isEntry) {
      let entryAsset = entries[entries.length - 1]; // $FlowFixMe

      interpreter = bundle.target.env.isBrowser() ? null : entryAsset.meta.interpreter;
    } else if (bundle.env.outputFormat === 'global') {
      // The last entry is the main entry, but in async bundles we don't want it to execute until we require it
      // as there might be dependencies in a sibling bundle that hasn't loaded yet.
      entries.pop();
    }

    let sourceMapReference = await getSourceMapReference(map);
    return {
      contents: // If the entry asset included a hashbang, repeat it at the top of the bundle
      (interpreter != null ? `#!${interpreter}\n` : '') + (PRELUDE + '({' + assets + '},{},' + JSON.stringify(entries.map(asset => asset.id)) + ', ' + 'null' + ')\n\n' + '//# sourceMappingURL=' + sourceMapReference + '\n'),
      map
    };
  }

});

exports.default = _default;