"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _localRequire = require("@parcel/utils/src/localRequire");

var _micromatch = require("micromatch");

var _path = require("path");

var _plugin = require("@parcel/plugin");

var _logger = _interopRequireDefault(require("@parcel/logger"));

var _semver = _interopRequireDefault(require("semver"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const PARCEL_VERSION = require('../package.json').version;

class Config {
  constructor(config) {
    _defineProperty(this, "filePath", void 0);

    _defineProperty(this, "resolvers", void 0);

    _defineProperty(this, "transforms", void 0);

    _defineProperty(this, "bundler", void 0);

    _defineProperty(this, "namers", void 0);

    _defineProperty(this, "runtimes", void 0);

    _defineProperty(this, "packagers", void 0);

    _defineProperty(this, "optimizers", void 0);

    _defineProperty(this, "reporters", void 0);

    _defineProperty(this, "pluginCache", void 0);

    this.filePath = config.filePath;
    this.resolvers = config.resolvers || [];
    this.transforms = config.transforms || {};
    this.runtimes = config.runtimes || {};
    this.bundler = config.bundler || '';
    this.namers = config.namers || [];
    this.packagers = config.packagers || {};
    this.optimizers = config.optimizers || {};
    this.reporters = config.reporters || [];
    this.pluginCache = new Map();
  }

  serialize() {
    return {
      filePath: this.filePath,
      resolvers: this.resolvers,
      transforms: this.transforms,
      runtimes: this.runtimes,
      bundler: this.bundler,
      namers: this.namers,
      packagers: this.packagers,
      optimizers: this.optimizers,
      reporters: this.reporters
    };
  }

  async loadPlugin(pluginName) {
    let cached = this.pluginCache.get(pluginName);

    if (cached) {
      return cached;
    }

    let [resolved, pkg] = await (0, _localRequire.localResolve)(pluginName, this.filePath); // Validate the engines.parcel field in the plugin's package.json

    let parcelVersionRange = pkg && pkg.engines && pkg.engines.parcel;

    if (!parcelVersionRange) {
      _logger.default.warn(`The plugin "${pluginName}" needs to specify a \`package.json#engines.parcel\` field with the supported Parcel version range.`);
    }

    if (parcelVersionRange && !_semver.default.satisfies(PARCEL_VERSION, parcelVersionRange)) {
      throw new Error(`The plugin "${pluginName}" is not compatible with the current version of Parcel. Requires "${parcelVersionRange}" but the current version is "${PARCEL_VERSION}".`);
    } // $FlowFixMe


    let plugin = require(resolved);

    plugin = plugin.default ? plugin.default : plugin;
    plugin = plugin[_plugin.CONFIG];
    this.pluginCache.set(pluginName, plugin);
    return plugin;
  }

  async loadPlugins(plugins) {
    return Promise.all(plugins.map(pluginName => this.loadPlugin(pluginName)));
  }

  async getResolvers() {
    if (this.resolvers.length === 0) {
      throw new Error('No resolver plugins specified in .parcelrc config');
    }

    return this.loadPlugins(this.resolvers);
  }

  async getTransformers(filePath) {
    let transformers = this.matchGlobMapPipelines(filePath, this.transforms);

    if (!transformers || transformers.length === 0) {
      throw new Error(`No transformers found for "${filePath}".`);
    }

    return this.loadPlugins(transformers);
  }

  async getBundler() {
    if (!this.bundler) {
      throw new Error('No bundler specified in .parcelrc config');
    }

    return this.loadPlugin(this.bundler);
  }

  async getNamers() {
    if (this.namers.length === 0) {
      throw new Error('No namer plugins specified in .parcelrc config');
    }

    return this.loadPlugins(this.namers);
  }

  async getRuntimes(context) {
    let runtimes = this.runtimes[context];

    if (!runtimes) {
      return [];
    }

    return this.loadPlugins(runtimes);
  }

  async getPackager(filePath) {
    let packagerName = this.matchGlobMap(filePath, this.packagers);

    if (!packagerName) {
      throw new Error(`No packager found for "${filePath}".`);
    }

    return this.loadPlugin(packagerName);
  }

  async getOptimizers(filePath) {
    let optimizers = this.matchGlobMapPipelines(filePath, this.optimizers);

    if (!optimizers) {
      return [];
    }

    return this.loadPlugins(optimizers);
  }

  async getReporters() {
    return this.loadPlugins(this.reporters);
  }

  isGlobMatch(filePath, pattern) {
    return (0, _micromatch.isMatch)(filePath, pattern) || (0, _micromatch.isMatch)((0, _path.basename)(filePath), pattern);
  }

  matchGlobMap(filePath, globMap) {
    for (let pattern in globMap) {
      if (this.isGlobMatch(filePath, pattern)) {
        return globMap[pattern];
      }
    }

    return null;
  }

  matchGlobMapPipelines(filePath, globMap) {
    let matches = [];

    for (let pattern in globMap) {
      if (this.isGlobMatch(filePath, pattern)) {
        matches.push(globMap[pattern]);
      }
    }

    let flatten = () => {
      let pipeline = matches.shift() || [];
      let spreadIndex = pipeline.indexOf('...');

      if (spreadIndex >= 0) {
        pipeline = [...pipeline.slice(0, spreadIndex), ...flatten(), ...pipeline.slice(spreadIndex + 1)];
      }

      if (pipeline.includes('...')) {
        throw new Error('Only one spread parameter can be included in a config pipeline');
      }

      return pipeline;
    };

    let res = flatten();
    return res;
  }

}

exports.default = Config;

_defineProperty(Config, "__exportSpecifier", "@parcel/core/lib/Config.js");