"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _stream = require("stream");

var _crypto = _interopRequireDefault(require("crypto"));

var _sourceMap = _interopRequireDefault(require("@parcel/source-map"));

var _utils = require("@parcel/utils");

var _Dependency = _interopRequireDefault(require("./Dependency"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Asset {
  constructor(options) {
    _defineProperty(this, "id", void 0);

    _defineProperty(this, "hash", void 0);

    _defineProperty(this, "idBase", void 0);

    _defineProperty(this, "fs", void 0);

    _defineProperty(this, "filePath", void 0);

    _defineProperty(this, "type", void 0);

    _defineProperty(this, "ast", void 0);

    _defineProperty(this, "cache", void 0);

    _defineProperty(this, "map", void 0);

    _defineProperty(this, "mapKey", void 0);

    _defineProperty(this, "dependencies", void 0);

    _defineProperty(this, "connectedFiles", void 0);

    _defineProperty(this, "isIsolated", void 0);

    _defineProperty(this, "outputHash", void 0);

    _defineProperty(this, "env", void 0);

    _defineProperty(this, "meta", void 0);

    _defineProperty(this, "stats", void 0);

    _defineProperty(this, "content", void 0);

    _defineProperty(this, "contentKey", void 0);

    _defineProperty(this, "symbols", void 0);

    _defineProperty(this, "sideEffects", void 0);

    this.idBase = options.idBase != null ? options.idBase : options.filePath;
    this.id = options.id != null ? options.id : (0, _utils.md5FromString)(this.idBase + options.type + JSON.stringify(options.env));
    this.hash = options.hash;
    this.fs = options.fs;
    this.filePath = options.filePath;
    this.isIsolated = options.isIsolated == null ? false : options.isIsolated;
    this.type = options.type;
    this.content = options.content || '';
    this.contentKey = options.contentKey;
    this.ast = options.ast || null;
    this.cache = options.cache;
    this.map = options.map;
    this.mapKey = options.mapKey;
    this.dependencies = options.dependencies || new Map();
    this.connectedFiles = options.connectedFiles || new Map();
    this.outputHash = options.outputHash || '';
    this.env = options.env;
    this.meta = options.meta || {};
    this.stats = options.stats;
    this.symbols = options.symbols || new Map();
    this.sideEffects = options.sideEffects != null ? options.sideEffects : true;
  }

  static deserialize(opts) {
    return new Asset(opts);
  }

  serialize() {
    // Exclude `code`, `map`, and `ast` from cache
    return {
      id: this.id,
      hash: this.hash,
      fs: this.fs,
      filePath: this.filePath,
      cache: this.cache,
      type: this.type,
      dependencies: this.dependencies,
      connectedFiles: this.connectedFiles,
      isIsolated: this.isIsolated,
      outputHash: this.outputHash,
      env: this.env,
      meta: this.meta,
      stats: this.stats,
      contentKey: this.contentKey,
      mapKey: this.mapKey,
      symbols: this.symbols,
      sideEffects: this.sideEffects
    };
  }
  /*
   * Prepares the asset for being serialized to the cache by commiting its
   * content and map of the asset to the cache.
   */


  async commit(pipelineKey) {
    this.ast = null;
    let contentStream = this.getStream();

    if ( // $FlowFixMe
    typeof contentStream.bytesRead === 'number' && contentStream.bytesRead > 0) {
      throw new Error('Stream has already been read. This may happen if a plugin reads from a stream and does not replace it.');
    }

    let size = 0;

    let hash = _crypto.default.createHash('md5'); // Since we can only read from the stream once, compute the content length
    // and hash while it's being written to the cache.


    let [contentKey, mapKey] = await Promise.all([this.cache.setStream(this.generateCacheKey('content' + pipelineKey), contentStream.pipe(new _utils.TapStream(buf => {
      size += buf.length;
      hash.update(buf);
    }))), this.map == null ? Promise.resolve() : this.cache.set(this.generateCacheKey('map' + pipelineKey), this.map)]);
    this.contentKey = contentKey;
    this.mapKey = mapKey;
    this.stats.size = size;
    this.outputHash = hash.digest('hex');
  }

  async getCode() {
    if (this.contentKey != null) {
      this.content = this.cache.getStream(this.contentKey);
    }

    if (typeof this.content === 'string' || this.content instanceof Buffer) {
      this.content = this.content.toString();
    } else {
      this.content = (await (0, _utils.bufferStream)(this.content)).toString();
    }

    return this.content;
  }

  async getBuffer() {
    if (this.contentKey != null) {
      this.content = this.cache.getStream(this.contentKey);
    }

    if (typeof this.content === 'string' || this.content instanceof Buffer) {
      return Buffer.from(this.content);
    }

    this.content = await (0, _utils.bufferStream)(this.content);
    return this.content;
  }

  getStream() {
    if (this.contentKey != null) {
      this.content = this.cache.getStream(this.contentKey);
    }

    return (0, _utils.blobToStream)(this.content);
  }

  setCode(code) {
    this.content = code;
  }

  setBuffer(buffer) {
    this.content = buffer;
  }

  setStream(stream) {
    this.content = stream;
  }

  async getMap() {
    if (this.mapKey != null) {
      let cached = await this.cache.get(this.mapKey);

      if (cached != null) {
        this.map = _sourceMap.default.deserialize(cached);
      }
    }

    return this.map;
  }

  setMap(map) {
    this.map = map;
  }

  generateCacheKey(key) {
    return (0, _utils.md5FromString)(key + this.id + JSON.stringify(this.env));
  }

  addDependency(opts) {
    let {
      env
    } = opts,
        rest = _objectWithoutProperties(opts, ["env"]);

    let dep = new _Dependency.default(_objectSpread({}, rest, {
      env: this.env.merge(env),
      sourcePath: this.filePath
    }));
    let existing = this.dependencies.get(dep.id);

    if (existing) {
      existing.merge(dep);
    } else {
      this.dependencies.set(dep.id, dep);
    }

    return dep.id;
  }

  async addConnectedFile(file) {
    if (file.hash == null) {
      file.hash = await (0, _utils.md5FromFilePath)(this.fs, file.filePath);
    }

    this.connectedFiles.set(file.filePath, file);
  }

  getConnectedFiles() {
    return Array.from(this.connectedFiles.values());
  }

  getDependencies() {
    return Array.from(this.dependencies.values());
  }

  createChildAsset(result) {
    var _ref, _result$content, _result$sideEffects;

    let content = (_ref = (_result$content = result.content) !== null && _result$content !== void 0 ? _result$content : result.code) !== null && _ref !== void 0 ? _ref : '';
    let hash;
    let size;

    if (content === this.content) {
      hash = this.hash;
      size = this.stats.size;
    } else if (typeof content === 'string' || content instanceof Buffer) {
      hash = (0, _utils.md5FromString)(content);
      size = content.length;
    } else {
      hash = null;
      size = NaN;
    }

    let asset = new Asset({
      idBase: this.idBase,
      hash,
      fs: this.fs,
      filePath: this.filePath,
      type: result.type,
      content,
      cache: this.cache,
      ast: result.ast,
      map: result.map,
      isIsolated: result.isIsolated,
      env: this.env.merge(result.env),
      dependencies: new Map(this.dependencies),
      connectedFiles: new Map(this.connectedFiles),
      meta: _objectSpread({}, this.meta, result.meta),
      stats: {
        time: 0,
        size
      },
      symbols: new Map([...this.symbols, ...(result.symbols || [])]),
      sideEffects: (_result$sideEffects = result.sideEffects) !== null && _result$sideEffects !== void 0 ? _result$sideEffects : this.sideEffects
    });
    let dependencies = result.dependencies;

    if (dependencies) {
      for (let dep of dependencies) {
        asset.addDependency(dep);
      }
    }

    let connectedFiles = result.connectedFiles;

    if (connectedFiles) {
      for (let file of connectedFiles) {
        asset.addConnectedFile(file);
      }
    }

    return asset;
  }

  async getConfig(filePaths, options) {
    let packageKey = options === null || options === void 0 ? void 0 : options.packageKey;
    let parse = options && options.parse;

    if (packageKey != null) {
      let pkg = await this.getPackage();

      if (pkg && pkg[packageKey]) {
        return pkg[packageKey];
      }
    }

    let conf = await (0, _utils.loadConfig)(this.fs, this.filePath, filePaths, parse == null ? null : {
      parse
    });

    if (!conf) {
      return null;
    }

    for (let file of conf.files) {
      this.addConnectedFile(file);
    }

    return conf.config;
  }

  async getPackage() {
    return this.getConfig(['package.json']);
  }

}

exports.default = Asset;