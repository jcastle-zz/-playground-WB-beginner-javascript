"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = register;

var _module = _interopRequireDefault(require("module"));

var _path = _interopRequireDefault(require("path"));

var _pirates = require("pirates");

var _Parcel = _interopRequireWildcard(require("./Parcel"));

var _utils = require("@parcel/utils");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { keys.push.apply(keys, Object.getOwnPropertySymbols(object)); } if (enumerableOnly) keys = keys.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

let hooks = {};
let lastDisposable;

function register(opts) {
  // Replace old hook, as this one likely contains options.
  if (lastDisposable) {
    lastDisposable.dispose();
  }

  let parcel = new _Parcel.default(_objectSpread({
    logLevel: 'error'
  }, opts));
  let env = {
    context: 'node',
    engines: {
      node: process.versions.node
    }
  };
  (0, _utils.syncPromise)(parcel.init());
  let isProcessing = false; // As Parcel is pretty much fully asynchronous, create an async function and wrap it in a syncPromise later...

  async function fileProcessor(code, filePath) {
    if (isProcessing) {
      return code;
    }

    try {
      isProcessing = true; // $FlowFixMe

      let result = await parcel[_Parcel.INTERNAL_TRANSFORM]({
        filePath,
        env
      });

      if (result.assets && result.assets.length >= 1) {
        let output = '';
        let asset = result.assets.find(a => a.type === 'js');

        if (asset) {
          output = await asset.getCode();
        }

        return output;
      }
    } catch (e) {
      /* eslint-disable no-console */
      console.error('@parcel/register failed to process: ', filePath);
      console.error(e);
      /* eslint-enable */
    } finally {
      isProcessing = false;
    }

    return '';
  }

  let hookFunction = (...args) => (0, _utils.syncPromise)(fileProcessor(...args));

  function resolveFile(currFile, targetFile) {
    try {
      isProcessing = true;
      let resolved = (0, _utils.syncPromise)( // $FlowFixMe
      parcel[_Parcel.INTERNAL_RESOLVE]({
        moduleSpecifier: targetFile,
        sourcePath: currFile,
        env
      }));

      let targetFileExtension = _path.default.extname(resolved);

      if (!hooks[targetFileExtension]) {
        hooks[targetFileExtension] = (0, _pirates.addHook)(hookFunction, {
          exts: [targetFileExtension],
          ignoreNodeModules: false
        });
      }

      return resolved;
    } finally {
      isProcessing = false;
    }
  }

  hooks.js = (0, _pirates.addHook)(hookFunction, {
    exts: ['.js'],
    ignoreNodeModules: false
  });
  let disposed; // Patching Module._resolveFilename takes care of patching the underlying
  // resolver in both `require` and `require.resolve`:
  // https://github.com/nodejs/node-v0.x-archive/issues/1125#issuecomment-10748203

  const originalResolveFilename = _module.default._resolveFilename;

  _module.default._resolveFilename = function (to, from, ...rest) {
    return isProcessing || disposed ? originalResolveFilename(to, from, ...rest) : resolveFile(from === null || from === void 0 ? void 0 : from.filename, to);
  };

  let disposable = lastDisposable = {
    dispose() {
      if (disposed) {
        return;
      }

      for (let extension in hooks) {
        hooks[extension]();
      }

      disposed = true;
    }

  };
  return disposable;
}