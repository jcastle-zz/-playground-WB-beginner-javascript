"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Asset = require("./Asset");

var _Bundle = require("./Bundle");

var _utils = require("./utils");

function _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to set private field on non-instance"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } return value; }

class MainAssetGraph {
  // AssetGraph
  constructor(graph) {
    _graph.set(this, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _graph, graph);
  }

  createBundle(asset) {
    let assetNode = _classPrivateFieldGet(this, _graph).getNode(asset.id);

    if (!assetNode) {
      throw new Error('Cannot get bundle for non-existent asset');
    }

    let graph = _classPrivateFieldGet(this, _graph).getSubGraph(assetNode);

    graph.setRootNode({
      type: 'root',
      id: 'root',
      value: null
    });
    graph.addEdge('root', assetNode.id); // Prune assets that don't match the bundle type when including the asset's
    // subgraph. These are replaced with asset references, but the concrete assets
    // cannot exist in this bundle.
    //
    // The concrete assets are visited when traversing the MainAssetGraph, so they
    // will have their own opportunity to be bundled in a bundle of the appropriate
    // type.

    graph.traverseAssets(currentAsset => {
      if (currentAsset.type !== asset.type) {
        graph.removeAsset(currentAsset);
      }
    });
    return new _Bundle.MutableBundle({
      id: 'bundle:' + asset.id,
      filePath: null,
      isEntry: null,
      target: null,
      name: null,
      type: asset.type,
      assetGraph: graph,
      env: asset.env,
      stats: {
        size: 0,
        time: 0
      }
    });
  }

  getDependencies(asset) {
    return _classPrivateFieldGet(this, _graph).getDependencies((0, _Asset.assetToInternalAsset)(asset));
  }

  getDependencyResolution(dep) {
    let resolution = _classPrivateFieldGet(this, _graph).getDependencyResolution(dep);

    if (resolution) {
      return new _Asset.Asset(resolution);
    }
  }

  getIncomingDependencies(asset) {
    return _classPrivateFieldGet(this, _graph).getIncomingDependencies((0, _Asset.assetToInternalAsset)(asset));
  }

  traverse(visit) {
    return _classPrivateFieldGet(this, _graph).filteredTraverse(node => {
      if (node.type === 'asset') {
        return {
          type: 'asset',
          value: new _Asset.Asset(node.value)
        };
      } else if (node.type === 'dependency') {
        return {
          type: 'dependency',
          value: node.value
        };
      }
    }, visit);
  }

  traverseAssets(visit) {
    return _classPrivateFieldGet(this, _graph).traverseAssets((0, _utils.assetGraphVisitorToInternal)(visit));
  }

  getHash() {
    return _classPrivateFieldGet(this, _graph).getHash();
  }

}

exports.default = MainAssetGraph;

var _graph = new WeakMap();