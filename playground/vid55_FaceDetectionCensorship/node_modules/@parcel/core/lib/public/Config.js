"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("@parcel/utils");

var _Environment = _interopRequireDefault(require("./Environment"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classPrivateFieldGet(receiver, privateMap) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError("attempted to get private field on non-instance"); } if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

function _classPrivateFieldSet(receiver, privateMap, value) { var descriptor = privateMap.get(receiver); if (!descriptor) { throw new TypeError("attempted to set private field on non-instance"); } if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } return value; }

class PublicConfig {
  // Config;
  // ParcelOptions
  constructor(config, options) {
    _config.set(this, {
      writable: true,
      value: void 0
    });

    _options.set(this, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldSet(this, _config, config);

    _classPrivateFieldSet(this, _options, options);
  }

  get env() {
    return new _Environment.default(_classPrivateFieldGet(this, _config).env);
  }

  get searchPath() {
    return _classPrivateFieldGet(this, _config).searchPath;
  }

  get result() {
    return _classPrivateFieldGet(this, _config).result;
  }

  get isSource() {
    return _classPrivateFieldGet(this, _config).isSource;
  }

  setResolvedPath(filePath) {
    _classPrivateFieldGet(this, _config).resolvedPath = filePath;
  } // $FlowFixMe


  setResult(result) {
    _classPrivateFieldGet(this, _config).result = result;
  }

  setResultHash(resultHash) {
    _classPrivateFieldGet(this, _config).resultHash = resultHash;
  }

  addIncludedFile(filePath) {
    _classPrivateFieldGet(this, _config).includedFiles.add(filePath);
  }

  addDevDependency(name, version) {
    _classPrivateFieldGet(this, _config).devDeps.set(name, version);
  }

  setWatchGlob(glob) {
    _classPrivateFieldGet(this, _config).watchGlob = glob;
  }

  shouldRehydrate() {
    _classPrivateFieldGet(this, _config).shouldRehydrate = true;
  }

  shouldReload() {
    _classPrivateFieldGet(this, _config).shouldReload = true;
  }

  shouldInvalidateOnStartup() {
    _classPrivateFieldGet(this, _config).shouldInvalidateOnStartup = true;
  }

  async getConfigFrom(searchPath, filePaths, options) {
    let parse = options && options.parse;
    let conf = await (0, _utils.loadConfig)(_classPrivateFieldGet(this, _options).inputFS, searchPath, filePaths, parse == null ? null : {
      parse
    });

    if (conf == null) {
      return null;
    }

    if (!options || !options.exclude) {
      for (let file of conf.files) {
        this.addIncludedFile(file.filePath);
      }
    }

    return conf.config;
  }

  getConfig(filePaths, options) {
    return this.getConfigFrom(this.searchPath, filePaths, options);
  }

  async getPackage() {
    if (_classPrivateFieldGet(this, _config).pkg) {
      return _classPrivateFieldGet(this, _config).pkg;
    }

    _classPrivateFieldGet(this, _config).pkg = await this.getConfig(['package.json']);
    return _classPrivateFieldGet(this, _config).pkg;
  }

}

exports.default = PublicConfig;

var _config = new WeakMap();

var _options = new WeakMap();