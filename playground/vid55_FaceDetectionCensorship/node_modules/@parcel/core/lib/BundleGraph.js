"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeAssetGroups = removeAssetGroups;
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _crypto = _interopRequireDefault(require("crypto"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _utils = require("@parcel/utils");

var _utils2 = require("./utils");

var _Graph = _interopRequireWildcard(require("./Graph"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class BundleGraph {
  // TODO: These hashes are being invalidated in mutative methods, but this._graph is not a private
  // property so it is possible to reach in and mutate the graph without invalidating these hashes.
  // It needs to be exposed in BundlerRunner for now based on how applying runtimes works and the
  // BundlerRunner takes care of invalidating hashes when runtimes are applied, but this is not ideal.
  constructor({
    graph,
    bundleContentHashes
  }) {
    _defineProperty(this, "_bundleContentHashes", void 0);

    _defineProperty(this, "_graph", void 0);

    this._graph = graph;
    this._bundleContentHashes = bundleContentHashes || new Map();
  }

  static deserialize(opts) {
    return new BundleGraph({
      graph: opts._graph,
      bundleContentHashes: opts._bundleContentHashes
    });
  }

  addAssetGraphToBundle(asset, bundle) {
    // The root asset should be reached directly from the bundle in traversal.
    // Its children will be traversed from there.
    this._graph.addEdge(bundle.id, asset.id);

    this._graph.traverse((node, _, actions) => {
      if (node.type === 'bundle_group') {
        actions.skipChildren();
        return;
      }

      if (node.type === 'asset' && !this.bundleHasAsset(bundle, node.value)) {
        bundle.stats.size += node.value.stats.size;
      }

      if (node.type === 'asset' || node.type === 'dependency') {
        this._graph.addEdge(bundle.id, node.id, 'contains');
      }

      if (node.type === 'dependency') {
        for (let bundleGroupNode of this._graph.getNodesConnectedFrom(node).filter(node => node.type === 'bundle_group')) {
          this._graph.addEdge(bundle.id, bundleGroupNode.id, 'bundle');
        }
      }
    }, (0, _nullthrows.default)(this._graph.getNode(asset.id)));

    this._bundleContentHashes.delete(bundle.id);
  }

  removeAssetGraphFromBundle(asset, bundle) {
    if (this._graph.hasEdge(bundle.id, asset.id)) {
      this._graph.removeEdge(bundle.id, asset.id);
    }

    this._graph.traverse((node, context, actions) => {
      if (node.type === 'bundle_group') {
        actions.skipChildren();
        return;
      }

      if (node.type === 'asset' || node.type === 'dependency') {
        if (this._graph.hasEdge(bundle.id, node.id, 'contains')) {
          this._graph.removeEdge(bundle.id, node.id, 'contains');

          if (node.type === 'asset') {
            bundle.stats.size -= asset.stats.size;
          }
        } else {
          actions.skipChildren();
        }
      }

      if (node.type === 'dependency') {
        for (let bundleGroupNode of this._graph.getNodesConnectedFrom(node).filter(node => node.type === 'bundle_group')) {
          let inboundDependencies = this._graph.getNodesConnectedTo(bundleGroupNode).filter(node => node.type === 'dependency'); // If every inbound dependency to this bundle group does not belong to this bundle,
          // then the connection between this bundle and the group is safe to remove.


          if (inboundDependencies.every(depNode => !this._graph.hasEdge(bundle.id, depNode.id, 'contains'))) {
            this._graph.removeEdge(bundle.id, bundleGroupNode.id, 'bundle');
          }
        }
      }
    }, (0, _nullthrows.default)(this._graph.getNode(asset.id)));

    this._bundleContentHashes.delete(bundle.id);
  }

  createAssetReference(dependency, asset) {
    this._graph.addEdge(dependency.id, asset.id, 'references');

    if (this._graph.hasEdge(dependency.id, asset.id)) {
      this._graph.removeEdge(dependency.id, asset.id);
    }
  }

  findBundlesWithAsset(asset) {
    return this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(asset.id)), 'contains').filter(node => node.type === 'bundle').map(node => {
      (0, _assert.default)(node.type === 'bundle');
      return node.value;
    });
  }

  getDependencyAssets(dependency) {
    let dependencyNode = (0, _nullthrows.default)(this._graph.getNode(dependency.id));
    return this._graph.getNodesConnectedFrom(dependencyNode).filter(node => node.type === 'asset').map(node => {
      (0, _assert.default)(node.type === 'asset');
      return node.value;
    });
  }

  getDependencyResolution(dep) {
    let depNode = this._graph.getNode(dep.id);

    if (!depNode) {
      return null;
    }

    let res = null;

    function findFirstAsset(node, _, traversal) {
      if (node.type === 'asset') {
        res = node.value;
        traversal.stop();
      } else if (node.id !== dep.id) {
        traversal.skipChildren();
      }
    } // TODO: Combine with multiple edge type traversal?


    this._graph.traverse(findFirstAsset, depNode);

    if (!res) {
      // Prefer real assets when resolving dependencies, but use the first
      // asset reference in absence of a real one.
      this._graph.traverse(findFirstAsset, depNode, 'references');
    }

    return res;
  }

  getDependencies(asset) {
    let node = this._graph.getNode(asset.id);

    if (!node) {
      throw new Error('Asset not found');
    }

    return this._graph.getNodesConnectedFrom(node).map(node => {
      (0, _assert.default)(node.type === 'dependency');
      return node.value;
    });
  }

  traverseAssets(bundle, visit) {
    return this.traverseBundle(bundle, (0, _Graph.mapVisitor)(node => node.type === 'asset' ? node.value : null, visit));
  }

  isAssetReferenced(asset) {
    return this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(asset.id)), 'references').length > 0;
  }

  isAssetReferencedByAssetType(asset, type) {
    let referringBundles = new Set(this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(asset.id)), 'contains')); // is `asset` referenced by a dependency from an asset of `type`

    return this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(asset.id))).filter(node => {
      // Does this dependency belong to a bundle that does not include the
      // asset it resolves to? If so, this asset is needed by a bundle but
      // does not belong to it.
      return this._graph.getNodesConnectedTo(node, 'contains').filter(node => node.type === 'bundle').some(b => !referringBundles.has(b));
    }).map(node => {
      (0, _assert.default)(node.type === 'dependency');
      return this._graph.getNodesConnectedTo(node, null);
    }).reduce((acc, node) => acc.concat(node), []).filter(node => node.type === 'asset').some(node => {
      (0, _assert.default)(node.type === 'asset');
      return node.value.type === type;
    });
  }

  hasParentBundleOfType(bundle, type) {
    return this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(bundle.id)), 'bundle').map(node => this._graph.getNodesConnectedTo(node, 'bundle')).reduce((acc, v) => acc.concat(v), []).filter(node => node.type === 'bundle' && node.value.type === type).length > 0;
  }

  isAssetInAncestorBundles(bundle, asset) {
    let parentBundleNodes = (0, _utils.flatMap)(this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(bundle.id)), 'bundle'), bundleGroupNode => {
      (0, _assert.default)(bundleGroupNode.type === 'bundle_group');
      return this._graph.getNodesConnectedTo(bundleGroupNode, 'bundle');
    });
    return parentBundleNodes.every(parentNode => {
      let inBundle;

      this._graph.traverseAncestors(parentNode, (node, ctx, actions) => {
        if (node.type !== 'bundle' || node.id === bundle.id) {
          return;
        }

        if (this._graph.hasEdge(node.value.id, asset.id, 'contains')) {
          inBundle = true;
          actions.stop();
        }
      }, 'bundle');

      return inBundle;
    });
  }

  traverseBundle(bundle, visit) {
    return this._graph.filteredTraverse((node, actions) => {
      if (node.id === bundle.id) {
        return;
      }

      if (node.type === 'dependency' || node.type === 'asset') {
        if (this._graph.hasEdge(bundle.id, node.id, 'contains')) {
          return node;
        }
      }

      actions.skipChildren();
    }, visit, (0, _nullthrows.default)(this._graph.getNode(bundle.id)));
  }

  traverseContents(visit) {
    return this._graph.filteredTraverse(node => node.type === 'asset' || node.type === 'dependency' ? node : null, visit);
  }

  hasChildBundles(bundle) {
    let bundleNode = (0, _nullthrows.default)(this._graph.getNode(bundle.id));
    return this._graph.getNodesConnectedFrom(bundleNode, 'bundle').length > 0;
  }

  traverseBundles(visit, startBundle) {
    return this._graph.filteredTraverse(node => node.type === 'bundle' ? node.value : null, visit, startBundle ? (0, _nullthrows.default)(this._graph.getNode(startBundle.id)) : null, 'bundle');
  }

  getBundles() {
    let bundles = [];
    this.traverseBundles(bundle => {
      bundles.push(bundle);
    });
    return bundles;
  }

  getTotalSize(asset) {
    let size = 0;

    this._graph.traverse((node, _, actions) => {
      if (node.type === 'bundle_group') {
        actions.skipChildren();
        return;
      }

      if (node.type === 'asset') {
        size += node.value.stats.size;
      }
    }, (0, _nullthrows.default)(this._graph.getNode(asset.id)));

    return size;
  }

  getBundleGroupsContainingBundle(bundle) {
    return this._graph.getNodesConnectedTo((0, _nullthrows.default)(this._graph.getNode(bundle.id)), 'bundle').filter(node => node.type === 'bundle_group').map(node => {
      (0, _assert.default)(node.type === 'bundle_group');
      return node.value;
    });
  }

  getBundlesInBundleGroup(bundleGroup) {
    return this._graph.getNodesConnectedFrom((0, _nullthrows.default)(this._graph.getNode((0, _utils2.getBundleGroupId)(bundleGroup))), 'bundle').filter(node => node.type === 'bundle').map(node => {
      (0, _assert.default)(node.type === 'bundle');
      return node.value;
    });
  }

  getBundleGroupsReferencedByBundle(bundle) {
    let node = (0, _nullthrows.default)(this._graph.getNode(bundle.id), 'Bundle graph must contain bundle');
    let groupNodes = [];

    this._graph.traverse((node, context, actions) => {
      if (node.type === 'bundle_group') {
        groupNodes.push(node);
        actions.skipChildren();
      }
    }, node, 'bundle');

    return (0, _utils.flatMap)(groupNodes, groupNode => {
      return this._graph.getNodesConnectedTo(groupNode).filter(node => node.type === 'dependency' && this._graph.hasEdge(bundle.id, node.id, 'contains')).map(dependencyNode => {
        // TODO: Enforce non-null when bundle groups have the correct bundles
        // pointing to them
        (0, _assert.default)(dependencyNode.type === 'dependency');
        return {
          bundleGroup: groupNode.value,
          dependency: dependencyNode.value
        };
      });
    });
  }

  getIncomingDependencies(asset) {
    let node = this._graph.getNode(asset.id);

    if (!node) {
      return [];
    }

    return this._graph.findAncestors(node, node => node.type === 'dependency').map(node => {
      (0, _assert.default)(node.type === 'dependency');
      return node.value;
    });
  }

  bundleHasAsset(bundle, asset) {
    return this._graph.hasEdge(bundle.id, asset.id, 'contains');
  }

  filteredTraverse(bundle, filter, visit) {
    return this._graph.filteredTraverse(filter, visit, (0, _nullthrows.default)(this._graph.getNode(bundle.id)));
  }

  resolveSymbol(asset, symbol) {
    if (symbol === '*') {
      return {
        asset,
        exportSymbol: '*',
        symbol: '*'
      };
    }

    let identifier = asset.symbols.get(symbol);
    let deps = this.getDependencies(asset).reverse();

    for (let dep of deps) {
      // If this is a re-export, find the original module.
      let symbolLookup = new Map([...dep.symbols].map(([key, val]) => [val, key]));
      let depSymbol = symbolLookup.get(identifier);

      if (depSymbol != null) {
        let resolvedAsset = (0, _nullthrows.default)(this.getDependencyResolution(dep));
        let {
          asset,
          symbol: resolvedSymbol,
          exportSymbol
        } = this.resolveSymbol(resolvedAsset, depSymbol); // If it didn't resolve to anything (likely CommonJS), pass through where we got to

        if (resolvedSymbol == null) {
          return {
            asset,
            symbol: resolvedSymbol,
            exportSymbol
          };
        } // Otherwise, keep the original symbol name along with the resolved symbol


        return {
          asset,
          symbol: resolvedSymbol,
          exportSymbol: symbol
        };
      } // If this module exports wildcards, resolve the original module.
      // Default exports are excluded from wildcard exports.


      if (dep.symbols.get('*') === '*' && symbol !== 'default') {
        let resolved = (0, _nullthrows.default)(this.getDependencyResolution(dep));
        let result = this.resolveSymbol(resolved, symbol);

        if (result.symbol != null) {
          return {
            asset: result.asset,
            symbol: result.symbol,
            exportSymbol: symbol
          };
        }
      }
    }

    return {
      asset,
      exportSymbol: symbol,
      symbol: identifier
    };
  }

  getExportedSymbols(asset) {
    let symbols = [];

    for (let symbol of asset.symbols.keys()) {
      symbols.push(this.resolveSymbol(asset, symbol));
    }

    let deps = this.getDependencies(asset);

    for (let dep of deps) {
      if (dep.symbols.get('*') === '*') {
        let resolved = (0, _nullthrows.default)(this.getDependencyResolution(dep));
        let exported = this.getExportedSymbols(resolved).filter(s => s.exportSymbol !== 'default');
        symbols.push(...exported);
      }
    }

    return symbols;
  }

  getContentHash(bundle) {
    let existingHash = this._bundleContentHashes.get(bundle.id);

    if (existingHash != null) {
      return existingHash;
    }

    let hash = _crypto.default.createHash('md5'); // TODO: sort??


    this.traverseAssets(bundle, asset => {
      hash.update([asset.outputHash, asset.filePath].join(':'));
    });
    let hashHex = hash.digest('hex');

    this._bundleContentHashes.set(bundle.id, hashHex);

    return hashHex;
  }

  getHash(bundle) {
    let hash = _crypto.default.createHash('md5');

    this.traverseBundles(childBundle => {
      hash.update(this.getContentHash(childBundle));
    }, bundle);
    hash.update(JSON.stringify((0, _utils.objectSortedEntriesDeep)(bundle.env)));
    return hash.digest('hex');
  }

}

exports.default = BundleGraph;

function removeAssetGroups(assetGraph) {
  let graph = new _Graph.default(); // $FlowFixMe

  graph.setRootNode((0, _nullthrows.default)(assetGraph.getRootNode()));
  let assetGroupIds = new Set();
  assetGraph.traverse(node => {
    if (node.type === 'asset_group') {
      assetGroupIds.add(node.id);
    } else {
      graph.addNode(node);
    }
  });

  for (let edge of assetGraph.getAllEdges()) {
    let fromIds;

    if (assetGroupIds.has(edge.from)) {
      fromIds = [...assetGraph.inboundEdges.get(edge.from).get(null)];
    } else {
      fromIds = [edge.from];
    }

    for (let from of fromIds) {
      if (assetGroupIds.has(edge.to)) {
        for (let to of assetGraph.outboundEdges.get(edge.to).get(null)) {
          graph.addEdge(from, to);
        }
      } else {
        graph.addEdge(from, edge.to);
      }
    }
  }

  return graph;
}