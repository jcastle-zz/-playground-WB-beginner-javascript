"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = applyRuntimes;

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _AssetGraph = _interopRequireWildcard(require("./AssetGraph"));

var _BundleGraph = _interopRequireDefault(require("./public/BundleGraph"));

var _BundleGraph2 = require("./BundleGraph");

var _Bundle = require("./public/Bundle");

var _utils = require("@parcel/utils");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function applyRuntimes({
  bundleGraph,
  config,
  options,
  pluginOptions,
  runtimesBuilder
}) {
  let connections = [];

  for (let bundle of bundleGraph.getBundles()) {
    let runtimes = await config.getRuntimes(bundle.env.context);

    for (let runtime of runtimes) {
      let applied = await runtime.apply({
        bundle: new _Bundle.NamedBundle(bundle, bundleGraph, options),
        bundleGraph: new _BundleGraph.default(bundleGraph, options),
        options: pluginOptions
      });

      if (applied) {
        let runtimeAssets = Array.isArray(applied) ? applied : [applied];

        for (let _ref of runtimeAssets) {
          let {
            code,
            dependency,
            filePath,
            isEntry
          } = _ref;
          let assetRequest = {
            code,
            filePath,
            env: bundle.env
          };
          connections.push({
            bundle,
            assetRequest,
            dependency: dependency,
            isEntry
          });
        }
      }
    }
  }

  let runtimesAssetGraph = await reconcileNewRuntimes(runtimesBuilder, connections);
  let runtimesGraph = (0, _BundleGraph2.removeAssetGroups)(runtimesAssetGraph); // merge the transformed asset into the bundle's graph, and connect
  // the node to it.
  // $FlowFixMe

  bundleGraph._graph.merge(runtimesGraph);

  for (let _ref2 of connections) {
    let {
      bundle,
      assetRequest,
      dependency,
      isEntry
    } = _ref2;
    let assetGroupNode = (0, _AssetGraph.nodeFromAssetGroup)(assetRequest);
    let assetGroupAssets = runtimesAssetGraph.getNodesConnectedFrom(assetGroupNode);
    (0, _assert.default)(assetGroupAssets.length === 1);
    let runtimeNode = assetGroupAssets[0];
    (0, _assert.default)(runtimeNode.type === 'asset');
    let duplicatedAssetIds = new Set();
    runtimesGraph.traverse((node, _, actions) => {
      if (node.type !== 'dependency') {
        return;
      }

      let assets = runtimesGraph.getNodesConnectedFrom(node).map(assetNode => {
        (0, _assert.default)(assetNode.type === 'asset');
        return assetNode.value;
      });

      for (let asset of assets) {
        if (bundleGraph.isAssetInAncestorBundles(bundle, asset)) {
          duplicatedAssetIds.add(asset.id);
          actions.skipChildren();
        }
      }
    }, runtimeNode);
    runtimesGraph.traverse((node, _, actions) => {
      if (node.type === 'asset' || node.type === 'dependency') {
        if (duplicatedAssetIds.has(node.id)) {
          actions.skipChildren();
          return;
        }

        bundleGraph._graph.addEdge(bundle.id, node.id, 'contains');
      }
    }, runtimeNode);

    bundleGraph._graph.addEdge(dependency ? dependency.id : (0, _nullthrows.default)(bundleGraph._graph.getNode(bundle.id)).id, runtimeNode.id);

    if (isEntry) {
      bundle.entryAssetIds.unshift(runtimeNode.id);
    }
  }
}

async function reconcileNewRuntimes(runtimesBuilder, connections) {
  let {
    assetGraph
  } = runtimesBuilder;
  let assetRequestNodesById = new Map(connections.map(t => t.assetRequest).map(request => {
    let node = (0, _AssetGraph.nodeFromAssetGroup)(request);
    return [node.id, node];
  }));
  let newRequestIds = new Set(assetRequestNodesById.keys());
  let oldRequestIds = new Set(assetGraph.getEntryAssetGroupNodes().map(node => node.id));
  let toAdd = (0, _utils.setDifference)(newRequestIds, oldRequestIds);
  let toRemove = (0, _utils.setDifference)(oldRequestIds, newRequestIds);
  assetGraph.replaceNodesConnectedTo((0, _nullthrows.default)(assetGraph.getRootNode()), [...toAdd].map(requestId => (0, _nullthrows.default)(assetRequestNodesById.get(requestId))), node => toRemove.has(node.id)); // rebuild the graph

  return (await runtimesBuilder.build()).assetGraph;
}