"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("@parcel/utils");

var _Environment = require("./Environment");

var _path = _interopRequireDefault(require("path"));

var _browserslist = _interopRequireDefault(require("browserslist"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { keys.push.apply(keys, Object.getOwnPropertySymbols(object)); } if (enumerableOnly) keys = keys.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const DEFAULT_DEVELOPMENT_ENGINES = {
  node: 'current',
  browsers: ['last 1 Chrome version', 'last 1 Safari version', 'last 1 Firefox version', 'last 1 Edge version']
};
const DEFAULT_PRODUCTION_ENGINES = {
  browsers: ['>= 0.25%'],
  node: '8'
};
const DEFAULT_DIST_DIRNAME = 'dist';
const COMMON_TARGETS = ['main', 'module', 'browser', 'types'];

class TargetResolver {
  constructor(options) {
    _defineProperty(this, "fs", void 0);

    _defineProperty(this, "options", void 0);

    this.fs = options.inputFS;
    this.options = options;
  }

  async resolve(rootDir) {
    let optionTargets = this.options.targets;
    let targets;
    let files = [];

    if (optionTargets) {
      if (Array.isArray(optionTargets)) {
        if (optionTargets.length === 0) {
          throw new Error('Targets was an empty array');
        } // If an array of strings is passed, it's a filter on the resolved package
        // targets. Load them, and find the matching targets.


        let packageTargets = await this.resolvePackageTargets(rootDir);
        targets = optionTargets.map(target => {
          let matchingTarget = packageTargets.targets.get(target);

          if (!matchingTarget) {
            throw new Error(`Could not find target with name ${target}`);
          }

          return matchingTarget;
        });
        files = packageTargets.files;
      } else {
        // Otherwise, it's an object map of target descriptors (similar to those
        // in package.json). Adapt them to native targets.
        targets = Object.entries(optionTargets).map(([name, _descriptor]) => {
          // $FlowFixMe
          let descriptor = _descriptor;
          return {
            name,
            distDir: _path.default.resolve(this.fs.cwd(), descriptor.distDir),
            publicUrl: descriptor.publicUrl,
            env: (0, _Environment.createEnvironment)(descriptor),
            sourceMap: descriptor.sourceMap
          };
        });
      }

      if (this.options.serve) {
        // In serve mode, we only support a single browser target. If the user
        // provided more than one, or the matching target is not a browser, throw.
        if (targets.length > 1) {
          throw new Error('More than one target is not supported in serve mode');
        }

        if (targets[0].env.context !== 'browser') {
          throw new Error('Only browser targets are supported in serve mode');
        }
      }
    } else {
      // Explicit targets were not provided. Either use a modern target for server
      // mode, or simply use the package.json targets.
      if (this.options.serve) {
        var _serveOptions$publicU;

        // In serve mode, we only support a single browser target. Since the user
        // hasn't specified a target, use one targeting modern browsers for development
        let serveOptions = this.options.serve;
        targets = [{
          name: 'default',
          // For serve, write the `dist` to inside the parcel cache, which is
          // temporary, likely in a .gitignore or similar, but still readily
          // available for introspection by the user if necessary.
          distDir: _path.default.resolve(this.options.cacheDir, DEFAULT_DIST_DIRNAME),
          publicUrl: (_serveOptions$publicU = serveOptions.publicUrl) !== null && _serveOptions$publicU !== void 0 ? _serveOptions$publicU : '/',
          env: (0, _Environment.createEnvironment)({
            context: 'browser',
            engines: {
              browsers: DEFAULT_DEVELOPMENT_ENGINES.browsers
            }
          })
        }];
      } else {
        let packageTargets = await this.resolvePackageTargets(rootDir);
        targets = Array.from(packageTargets.targets.values());
        files = packageTargets.files;
      }
    }

    return {
      targets,
      files
    };
  }

  async resolvePackageTargets(rootDir) {
    var _this$options$default;

    let conf = await (0, _utils.loadConfig)(this.fs, _path.default.join(rootDir, 'index'), ['package.json']);
    let pkg;
    let pkgDir;

    if (conf) {
      pkg = conf.config;
      let pkgFile = conf.files[0];

      if (pkgFile == null) {
        throw new Error('Expected package.json file');
      }

      pkgDir = _path.default.dirname(pkgFile.filePath);
    } else {
      pkg = {};
      pkgDir = this.fs.cwd();
    }

    let pkgTargets = pkg.targets || {};

    let pkgEngines = _objectSpread({}, pkg.engines);

    if (!pkgEngines.browsers) {
      let browserslistBrowsers = _browserslist.default.loadConfig({
        path: rootDir
      });

      if (browserslistBrowsers) {
        pkgEngines.browsers = browserslistBrowsers;
      }
    }

    let targets = new Map();
    let node = pkgEngines.node;
    let browsers = pkgEngines.browsers; // If there is a separate `browser` target, or an `engines.node` field but no browser targets, then
    // the `main` and `module` targets refer to node, otherwise browser.

    let mainContext = pkg.browser || pkgTargets.browser || node && !browsers ? 'node' : 'browser';
    let moduleContext = pkg.browser || pkgTargets.browser ? 'browser' : mainContext;
    let defaultEngines = (_this$options$default = this.options.defaultEngines) !== null && _this$options$default !== void 0 ? _this$options$default : this.options.mode === 'production' ? DEFAULT_PRODUCTION_ENGINES : DEFAULT_DEVELOPMENT_ENGINES;
    let context = browsers || !node ? 'browser' : 'node';

    if (context === 'browser' && pkgEngines.browsers == null) {
      pkgEngines.browsers = defaultEngines.browsers;
    } else if (context === 'node' && pkgEngines.node == null) {
      pkgEngines.node = defaultEngines.node;
    }

    for (let targetName of COMMON_TARGETS) {
      let targetDist;

      if (targetName === 'browser' && pkg[targetName] != null && typeof pkg[targetName] === 'object') {
        // The `browser` field can be a file path or an alias map.
        targetDist = pkg[targetName][pkg.name];
      } else {
        targetDist = pkg[targetName];
      }

      if (typeof targetDist === 'string' || pkgTargets[targetName]) {
        var _descriptor$publicUrl, _descriptor$engines, _descriptor$context, _descriptor$includeNo, _descriptor$outputFor;

        let distDir;
        let distEntry;
        let descriptor = pkgTargets[targetName] || {};

        if (typeof targetDist === 'string') {
          distDir = _path.default.resolve(pkgDir, _path.default.dirname(targetDist));
          distEntry = _path.default.basename(targetDist);
        } else {
          distDir = _path.default.resolve(pkgDir, DEFAULT_DIST_DIRNAME, targetName);
        }

        targets.set(targetName, {
          name: targetName,
          distDir,
          distEntry,
          publicUrl: (_descriptor$publicUrl = descriptor.publicUrl) !== null && _descriptor$publicUrl !== void 0 ? _descriptor$publicUrl : '/',
          env: (0, _Environment.createEnvironment)({
            engines: (_descriptor$engines = descriptor.engines) !== null && _descriptor$engines !== void 0 ? _descriptor$engines : pkgEngines,
            context: (_descriptor$context = descriptor.context) !== null && _descriptor$context !== void 0 ? _descriptor$context : targetName === 'browser' ? 'browser' : targetName === 'module' ? moduleContext : mainContext,
            includeNodeModules: (_descriptor$includeNo = descriptor.includeNodeModules) !== null && _descriptor$includeNo !== void 0 ? _descriptor$includeNo : false,
            outputFormat: (_descriptor$outputFor = descriptor.outputFormat) !== null && _descriptor$outputFor !== void 0 ? _descriptor$outputFor : targetName === 'module' ? 'esmodule' : 'commonjs',
            isLibrary: true
          }),
          sourceMap: descriptor.sourceMap
        });
      }
    } // Custom targets


    for (let name in pkgTargets) {
      if (COMMON_TARGETS.includes(name)) {
        continue;
      }

      let descriptor = pkgTargets[name];
      let distPath = pkg[name];
      let distDir;
      let distEntry;

      if (distPath == null) {
        distDir = _path.default.resolve(pkgDir, DEFAULT_DIST_DIRNAME, name);
      } else {
        distDir = _path.default.resolve(pkgDir, _path.default.dirname(distPath));
        distEntry = _path.default.basename(distPath);
      }

      if (descriptor) {
        var _descriptor$publicUrl2, _descriptor$engines2;

        targets.set(name, {
          name,
          distDir,
          distEntry,
          publicUrl: (_descriptor$publicUrl2 = descriptor.publicUrl) !== null && _descriptor$publicUrl2 !== void 0 ? _descriptor$publicUrl2 : '/',
          env: (0, _Environment.createEnvironment)({
            engines: (_descriptor$engines2 = descriptor.engines) !== null && _descriptor$engines2 !== void 0 ? _descriptor$engines2 : pkgEngines,
            context: descriptor.context,
            includeNodeModules: descriptor.includeNodeModules,
            outputFormat: descriptor.outputFormat,
            isLibrary: descriptor.isLibrary
          }),
          sourceMap: descriptor.sourceMap
        });
      }
    } // If no explicit targets were defined, add a default.


    if (targets.size === 0) {
      targets.set('default', {
        name: 'default',
        distDir: _path.default.resolve(this.fs.cwd(), DEFAULT_DIST_DIRNAME),
        publicUrl: '/',
        env: (0, _Environment.createEnvironment)({
          engines: pkgEngines,
          context
        })
      });
    }

    return {
      targets,
      files: conf ? conf.files : []
    };
  }

}

exports.default = TargetResolver;