"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _path = _interopRequireDefault(require("path"));

var _utils = require("@parcel/utils");

var _workers = _interopRequireDefault(require("@parcel/workers"));

var _InternalConfig = require("./InternalConfig");

var _ConfigLoader = _interopRequireDefault(require("./ConfigLoader"));

var _Graph = _interopRequireDefault(require("./Graph"));

var _ResolverRunner = _interopRequireDefault(require("./ResolverRunner"));

var _EntryResolver = require("./EntryResolver");

var _TargetResolver = _interopRequireDefault(require("./TargetResolver"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { keys.push.apply(keys, Object.getOwnPropertySymbols(object)); } if (enumerableOnly) keys = keys.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const nodeFromDepPathRequest = dep => ({
  id: dep.id,
  type: 'dep_path_request',
  value: dep
});

const nodeFromConfigRequest = configRequest => ({
  id: (0, _utils.md5FromObject)({
    filePath: configRequest.filePath,
    plugin: configRequest.plugin,
    env: configRequest.env,
    pipeline: configRequest.pipeline
  }),
  type: 'config_request',
  value: configRequest
});

const nodeFromDepVersionRequest = depVersionRequest => ({
  id: (0, _utils.md5FromObject)(depVersionRequest),
  type: 'dep_version_request',
  value: depVersionRequest
});

const nodeFromFilePath = filePath => ({
  id: filePath,
  type: 'file',
  value: {
    filePath
  }
});

const nodeFromGlob = glob => ({
  id: glob,
  type: 'glob',
  value: glob
});

const nodeFromEntryRequest = entry => ({
  id: 'entry_request:' + entry,
  type: 'entry_request',
  value: entry
});

const nodeFromTargetRequest = entry => ({
  id: 'target_request:' + entry,
  type: 'target_request',
  value: entry
});

class RequestGraph extends _Graph.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "inProgress", new Map());

    _defineProperty(this, "invalidNodeIds", new Set());

    _defineProperty(this, "runTransform", void 0);

    _defineProperty(this, "runValidate", void 0);

    _defineProperty(this, "loadConfigHandle", void 0);

    _defineProperty(this, "entryResolver", void 0);

    _defineProperty(this, "targetResolver", void 0);

    _defineProperty(this, "resolverRunner", void 0);

    _defineProperty(this, "configLoader", void 0);

    _defineProperty(this, "onEntryRequestComplete", void 0);

    _defineProperty(this, "onTargetRequestComplete", void 0);

    _defineProperty(this, "onAssetRequestComplete", void 0);

    _defineProperty(this, "onDepPathRequestComplete", void 0);

    _defineProperty(this, "queue", void 0);

    _defineProperty(this, "validationQueue", void 0);

    _defineProperty(this, "farm", void 0);

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "globNodeIds", new Set());

    _defineProperty(this, "unpredicatableNodeIds", new Set());

    _defineProperty(this, "depVersionRequestNodeIds", new Set());
  }

  // $FlowFixMe
  static deserialize(opts) {
    let deserialized = new RequestGraph(opts);
    deserialized.invalidNodeIds = opts.invalidNodeIds;
    deserialized.globNodeIds = opts.globNodeIds;
    deserialized.depVersionRequestNodeIds = opts.depVersionRequestNodeIds;
    deserialized.unpredicatableNodeIds = opts.unpredicatableNodeIds; // $FlowFixMe

    return deserialized;
  } // $FlowFixMe


  serialize() {
    return _objectSpread({}, super.serialize(), {
      invalidNodeIds: this.invalidNodeIds,
      globNodeIds: this.globNodeIds,
      unpredicatableNodeIds: this.unpredicatableNodeIds,
      depVersionRequestNodeIds: this.depVersionRequestNodeIds
    });
  }

  initOptions({
    onAssetRequestComplete,
    onDepPathRequestComplete,
    onEntryRequestComplete,
    onTargetRequestComplete,
    config,
    options,
    workerFarm
  }) {
    this.options = options;
    this.queue = new _utils.PromiseQueue();
    this.validationQueue = new _utils.PromiseQueue();
    this.onAssetRequestComplete = onAssetRequestComplete;
    this.onDepPathRequestComplete = onDepPathRequestComplete;
    this.onEntryRequestComplete = onEntryRequestComplete;
    this.onTargetRequestComplete = onTargetRequestComplete;
    this.config = config;
    this.entryResolver = new _EntryResolver.EntryResolver(this.options);
    this.targetResolver = new _TargetResolver.default(this.options);
    this.resolverRunner = new _ResolverRunner.default({
      config,
      options
    });
    this.farm = workerFarm;
    this.runTransform = this.farm.createHandle('runTransform');
    this.runValidate = this.farm.createHandle('runValidate'); // $FlowFixMe

    this.loadConfigHandle = this.farm.createReverseHandle(this.loadConfig.bind(this));
    this.configLoader = new _ConfigLoader.default(options);
  }

  async completeValidations() {
    await this.validationQueue.run();
  }

  async completeRequests() {
    for (let id of this.invalidNodeIds) {
      let node = (0, _nullthrows.default)(this.getNode(id));
      this.processNode(node);
    }

    await this.queue.run();
  }

  addNode(node) {
    if (!this.hasNode(node.id)) {
      this.processNode(node);

      if (node.type === 'glob') {
        this.globNodeIds.add(node.id);
      } else if (node.type === 'dep_version_request') {
        this.depVersionRequestNodeIds.add(node.id);
      }
    }

    return super.addNode(node);
  }

  removeNode(node) {
    if (node.type === 'glob') {
      this.globNodeIds.delete(node.id);
    } else if (node.type === 'dep_version_request') {
      this.depVersionRequestNodeIds.delete(node.id);
    } else if (node.type === 'config_request') {
      this.unpredicatableNodeIds.delete(node.id);
    }

    return super.removeNode(node);
  }

  addEntryRequest(entry) {
    let requestNode = nodeFromEntryRequest(entry);

    if (!this.hasNode(requestNode.id)) {
      this.addNode(requestNode);
    }
  }

  addTargetRequest(entry) {
    let requestNode = nodeFromTargetRequest(entry);

    if (!this.hasNode(requestNode.id)) {
      this.addNode(requestNode);
    }
  }

  addDepPathRequest(dep) {
    let requestNode = nodeFromDepPathRequest(dep);

    if (!this.hasNode(requestNode.id)) {
      this.addNode(requestNode);
    }
  }

  addAssetRequest(id, request) {
    let requestNode = {
      id,
      type: 'asset_request',
      value: request
    };

    if (!this.hasNode(requestNode.id)) {
      this.addNode(requestNode);
    }

    this.connectFile(requestNode, request.filePath);
  }

  async processNode(requestNode) {
    let promise;

    switch (requestNode.type) {
      case 'entry_request':
        promise = this.queue.add(() => this.resolveEntry(requestNode));
        break;

      case 'target_request':
        promise = this.queue.add(() => this.resolveTargetRequest(requestNode));
        break;

      case 'asset_request':
        promise = this.queue.add(() => this.transform(requestNode));

        if (!requestNode.value.filePath.includes('node_modules') && this.config.getValidatorNames(requestNode.value.filePath).length > 0) {
          this.validationQueue.add(() => this.validate(requestNode));
        }

        break;

      case 'dep_path_request':
        promise = this.queue.add(() => this.resolvePath(requestNode.value).then(result => {
          if (result) {
            this.onDepPathRequestComplete(requestNode, result);
          }

          return result;
        }));
        break;

      case 'config_request':
        promise = this.runConfigRequest(requestNode);
        break;

      case 'dep_version_request':
        promise = this.runDepVersionRequest(requestNode);
        break;

      default:
        this.invalidNodeIds.delete(requestNode.id);
    }

    if (promise) {
      try {
        this.inProgress.set(requestNode.id, promise);
        await promise; // ? Should these be updated before it comes off the queue?

        this.invalidNodeIds.delete(requestNode.id);
      } catch (e) {// Do nothing
        // Main tasks will be caught by the queue
        // Sub tasks will end up rejecting the main task promise
      } finally {
        this.inProgress.delete(requestNode.id);
      }
    }
  }

  async validate(requestNode) {
    try {
      await this.runValidate({
        request: requestNode.value,
        loadConfig: this.loadConfigHandle,
        parentNodeId: requestNode.id,
        options: this.options
      });
    } catch (e) {
      throw e;
    }
  }

  async transform(requestNode) {
    try {
      let start = Date.now();
      let request = requestNode.value;
      let {
        assets,
        configRequests
      } = await this.runTransform({
        request,
        loadConfig: this.loadConfigHandle,
        parentNodeId: requestNode.id,
        options: this.options
      });
      let time = Date.now() - start;

      for (let asset of assets) {
        asset.stats.time = time;
      } // Ignore in case the request was deleted while transforming


      if (!this.hasNode(requestNode.id)) {
        return;
      }

      let configRequestNodes = configRequests.map(configRequest => {
        let node = nodeFromConfigRequest(configRequest);
        return this.getNode(node.id) || node;
      });
      this.replaceNodesConnectedTo(requestNode, configRequestNodes, node => node.type === 'config_request');
      this.onAssetRequestComplete(requestNode, assets);
      return assets;
    } catch (e) {
      // TODO: add includedFiles even if it failed so we can try a rebuild if those files change
      throw e;
    }
  }

  async resolveEntry(entryRequestNode) {
    let result = await this.entryResolver.resolveEntry(entryRequestNode.value); // Connect files like package.json that affect the entry
    // resolution so we invalidate when they change.

    for (let file of result.files) {
      this.connectFile(entryRequestNode, file.filePath);
    } // If the entry specifier is a glob, add a glob node so
    // we invalidate when a new file matches.


    if ((0, _utils.isGlob)(entryRequestNode.value)) {
      this.connectGlob(entryRequestNode, entryRequestNode.value);
    }

    this.onEntryRequestComplete(entryRequestNode.value, result.entries);
  }

  async resolveTargetRequest(targetRequestNode) {
    let result = await this.targetResolver.resolve(_path.default.dirname(targetRequestNode.value)); // Connect files like package.json that affect the target
    // resolution so we invalidate when they change.

    for (let file of result.files) {
      this.connectFile(targetRequestNode, file.filePath);
    }

    this.onTargetRequestComplete(targetRequestNode.value, result.targets);
  }

  async resolvePath(dep) {
    let assetRequest = await this.resolverRunner.resolve(dep);

    if (assetRequest) {
      this.connectFile(nodeFromDepPathRequest(dep), assetRequest.filePath);
    }

    return assetRequest;
  }

  async loadConfig(configRequest, parentNodeId) {
    if (!this.hasNode(parentNodeId)) {
      return this.configLoader.load(configRequest);
    }

    let configRequestNode = nodeFromConfigRequest(configRequest);

    if (!this.hasNode(configRequestNode.id)) {
      this.addNode(configRequestNode);
    }

    this.addEdge(parentNodeId, configRequestNode.id);
    let config = (0, _nullthrows.default)((await this.getSubTaskResult(configRequestNode)));
    (0, _assert.default)(config.devDeps != null); // ConfigRequest node might have been deleted while waiting for config to resolve

    if (!this.hasNode(configRequestNode.id)) {
      return config;
    }

    let depVersionRequestNodes = [];

    for (let [moduleSpecifier, version] of config.devDeps) {
      let depVersionRequest = {
        moduleSpecifier,
        resolveFrom: config.resolvedPath,
        // TODO: resolveFrom should be nearest package boundary
        result: version
      };
      let depVersionRequestNode = nodeFromDepVersionRequest(depVersionRequest);

      if (!this.hasNode(depVersionRequestNode.id) || version) {
        this.addNode(depVersionRequestNode);
      }

      this.addEdge(configRequestNode.id, depVersionRequestNode.id);
      depVersionRequestNodes.push((0, _nullthrows.default)(this.getNode(depVersionRequestNode.id)));

      if (version == null) {
        let result = await this.getSubTaskResult(depVersionRequestNode);
        (0, _InternalConfig.addDevDependency)(config, depVersionRequest.moduleSpecifier, result);
      }
    }

    this.replaceNodesConnectedTo(configRequestNode, depVersionRequestNodes, node => node.type === 'dep_version_request');
    return config;
  }

  async runConfigRequest(configRequestNode) {
    let configRequest = configRequestNode.value;
    let config = await this.configLoader.load(configRequest); // Config request could have been deleted while loading

    if (!this.hasNode(configRequestNode.id)) {
      return config;
    }

    configRequest.result = config;
    let invalidationNodes = [];

    if (config.resolvedPath != null) {
      invalidationNodes.push(nodeFromFilePath(config.resolvedPath));
    }

    for (let filePath of config.includedFiles) {
      invalidationNodes.push(nodeFromFilePath(filePath));
    }

    if (config.watchGlob != null) {
      invalidationNodes.push(nodeFromGlob(config.watchGlob));
    }

    this.replaceNodesConnectedTo(configRequestNode, invalidationNodes, node => node.type === 'file' || node.type === 'glob');

    if (config.shouldInvalidateOnStartup) {
      this.unpredicatableNodeIds.add(configRequestNode.id);
    } else {
      this.unpredicatableNodeIds.delete(configRequestNode.id);
    }

    return config;
  }

  async runDepVersionRequest(requestNode) {
    let {
      value: request
    } = requestNode;
    let {
      moduleSpecifier,
      resolveFrom,
      result
    } = request;
    let version = result;

    if (version == null) {
      let {
        pkg
      } = await this.options.packageManager.resolve(`${moduleSpecifier}/package.json`, `${resolveFrom}/index`); // TODO: Figure out how to handle when local plugin packages change, since version won't be enough

      version = (0, _nullthrows.default)(pkg).version;
      request.result = version;
    }

    return version;
  } //$FlowFixMe


  async getSubTaskResult(node) {
    let result;

    if (this.inProgress.has(node.id)) {
      result = await this.inProgress.get(node.id);
    } else {
      result = this.getResultFromGraph(node);
    }

    return result;
  }

  getResultFromGraph(subRequestNode) {
    let node = (0, _nullthrows.default)(this.getNode(subRequestNode.id));
    (0, _assert.default)(node.type === 'config_request' || node.type === 'dep_version_request');
    return node.value.result;
  }

  connectFile(requestNode, filePath) {
    if (!this.hasNode(requestNode.id)) {
      return;
    }

    let fileNode = nodeFromFilePath(filePath);

    if (!this.hasNode(fileNode.id)) {
      this.addNode(fileNode);
    }

    if (!this.hasEdge(requestNode.id, fileNode.id)) {
      this.addEdge(requestNode.id, fileNode.id);
    }
  }

  connectGlob(requestNode, glob) {
    if (!this.hasNode(requestNode.id)) {
      return;
    }

    let globNode = nodeFromGlob(glob);

    if (!this.hasNode(globNode.id)) {
      this.addNode(globNode);
    }

    if (!this.hasEdge(requestNode.id, globNode.id)) {
      this.addEdge(requestNode.id, globNode.id);
    }
  }

  invalidateNode(node) {
    switch (node.type) {
      case 'asset_request':
      case 'dep_path_request':
      case 'entry_request':
      case 'target_request':
        this.invalidNodeIds.add(node.id);
        break;

      case 'config_request':
      case 'dep_version_request':
        {
          this.invalidNodeIds.add(node.id);
          let mainRequestNode = (0, _nullthrows.default)(this.getMainRequestNode(node));
          this.invalidNodeIds.add(mainRequestNode.id);
          break;
        }

      default:
        throw new Error(`Cannot invalidate node with unrecognized type ${node.type}`);
    }
  }

  invalidateUnpredictableNodes() {
    for (let nodeId of this.unpredicatableNodeIds) {
      let node = (0, _nullthrows.default)(this.getNode(nodeId));
      (0, _assert.default)(node.type !== 'file' && node.type !== 'glob');
      this.invalidateNode(node);
    }
  }

  getMainRequestNode(node) {
    let [parentNode] = this.getNodesConnectedTo(node);

    if (parentNode.type === 'config_request') {
      [parentNode] = this.getNodesConnectedTo(parentNode);
    }

    (0, _assert.default)(parentNode.type !== 'file' && parentNode.type !== 'glob');
    return parentNode;
  } // TODO: add edge types to make invalidation more flexible and less precarious


  respondToFSEvents(events) {
    let isInvalid = false;

    for (let _ref of events) {
      let {
        path,
        type
      } = _ref;

      if (path === this.options.lockFile) {
        for (let id of this.depVersionRequestNodeIds) {
          let depVersionRequestNode = this.getNode(id);
          (0, _assert.default)(depVersionRequestNode && depVersionRequestNode.type === 'dep_version_request');
          this.invalidateNode(depVersionRequestNode);
          isInvalid = true;
        }
      }

      let node = this.getNode(path);
      let connectedNodes = node && node.type === 'file' ? this.getNodesConnectedTo(node) : []; // TODO: invalidate dep path requests that have failed and this creation may fulfill the request

      if (node && (type === 'create' || type === 'update')) {
        // sometimes mac reports update events as create events
        if (node.type === 'file') {
          for (let connectedNode of connectedNodes) {
            if (connectedNode.type === 'asset_request' || connectedNode.type === 'config_request' || connectedNode.type === 'entry_request' || connectedNode.type === 'target_request') {
              this.invalidateNode(connectedNode);
              isInvalid = true;
            }
          }
        }
      } else if (type === 'create') {
        for (let id of this.globNodeIds) {
          let globNode = this.getNode(id);
          (0, _assert.default)(globNode && globNode.type === 'glob');

          if ((0, _utils.isGlobMatch)(path, globNode.value)) {
            let connectedNodes = this.getNodesConnectedTo(globNode);

            for (let connectedNode of connectedNodes) {
              (0, _assert.default)(connectedNode.type !== 'file' && connectedNode.type !== 'glob');
              this.invalidateNode(connectedNode);
              isInvalid = true;
            }
          }
        }
      } else if (node && type === 'delete') {
        for (let connectedNode of connectedNodes) {
          if (connectedNode.type === 'dep_path_request' || connectedNode.type === 'config_request') {
            this.invalidateNode(connectedNode);
            isInvalid = true;
          }
        }
      }
    }

    return isInvalid;
  }

}

exports.default = RequestGraph;