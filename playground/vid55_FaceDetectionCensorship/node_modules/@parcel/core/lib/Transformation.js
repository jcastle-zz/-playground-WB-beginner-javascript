"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _path = _interopRequireDefault(require("path"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _utils = require("@parcel/utils");

var _Dependency = require("./Dependency");

var _Config = _interopRequireDefault(require("./public/Config"));

var _ParcelConfig = _interopRequireDefault(require("./ParcelConfig"));

var _ResolverRunner = _interopRequireDefault(require("./ResolverRunner"));

var _ReporterRunner = require("./ReporterRunner");

var _Asset = require("./public/Asset");

var _InternalAsset = _interopRequireWildcard(require("./InternalAsset"));

var _summarizeRequest = _interopRequireDefault(require("./summarizeRequest"));

var _PluginOptions = _interopRequireDefault(require("./public/PluginOptions"));

var _constants = require("./constants");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { keys.push.apply(keys, Object.getOwnPropertySymbols(object)); } if (enumerableOnly) keys = keys.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Transformation {
  constructor({
    request,
    loadConfig,
    parentNodeId,
    options,
    workerApi
  }) {
    _defineProperty(this, "request", void 0);

    _defineProperty(this, "configRequests", void 0);

    _defineProperty(this, "loadConfig", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "impactfulOptions", void 0);

    _defineProperty(this, "workerApi", void 0);

    this.request = request;
    this.configRequests = [];

    this.loadConfig = configRequest => {
      this.configRequests.push(configRequest);
      return loadConfig(configRequest, parentNodeId);
    };

    this.options = options;
    this.workerApi = workerApi; // TODO: these options may not impact all transformations, let transformers decide if they care or not

    let {
      minify,
      hot,
      scopeHoist
    } = this.options;
    this.impactfulOptions = {
      minify,
      hot,
      scopeHoist
    };
  }

  async run() {
    (0, _ReporterRunner.report)({
      type: 'buildProgress',
      phase: 'transforming',
      filePath: this.request.filePath
    });
    let asset = await this.loadAsset();
    let pipeline = await this.loadPipeline(this.request.filePath, asset.value.isSource, this.request.pipeline);
    let results = await this.runPipeline(pipeline, asset);
    let assets = results.map(a => a.value);
    return {
      assets,
      configRequests: this.configRequests
    };
  }

  async loadAsset() {
    let {
      filePath,
      env,
      code,
      sideEffects
    } = this.request;
    let {
      content,
      size,
      hash,
      isSource
    } = await (0, _summarizeRequest.default)(this.options.inputFS, this.request); // If the transformer request passed code rather than a filename,
    // use a hash as the base for the id to ensure it is unique.

    let idBase = code != null ? hash : filePath;
    return new _InternalAsset.default({
      idBase,
      value: (0, _InternalAsset.createAsset)({
        idBase,
        filePath,
        isSource,
        type: _path.default.extname(filePath).slice(1),
        hash,
        env,
        stats: {
          time: 0,
          size
        },
        sideEffects
      }),
      options: this.options,
      content
    });
  }

  async runPipeline(pipeline, initialAsset) {
    var _ref, _processedCacheEntry;

    let initialType = initialAsset.value.type;
    let initialAssetCacheKey = this.getCacheKey([initialAsset], pipeline.configs); // TODO: is this reading/writing from the cache every time we jump a pipeline? Seems possibly unnecessary...

    let initialCacheEntry = await this.readFromCache(initialAssetCacheKey);
    let assets = initialCacheEntry || (await pipeline.transform(initialAsset));

    if (!initialCacheEntry) {
      await this.writeToCache(initialAssetCacheKey, assets, pipeline.configs);
    }

    let finalAssets = [];

    for (let asset of assets) {
      let nextPipeline;

      if (asset.value.type !== initialType) {
        nextPipeline = await this.loadNextPipeline({
          filePath: initialAsset.value.filePath,
          isSource: asset.value.isSource,
          nextType: asset.value.type,
          currentPipeline: pipeline
        });
      }

      if (nextPipeline) {
        let nextPipelineAssets = await this.runPipeline(nextPipeline, asset);
        finalAssets = finalAssets.concat(nextPipelineAssets);
      } else {
        finalAssets.push(asset);
      }
    }

    if (!pipeline.postProcess) {
      return finalAssets;
    }

    let processedCacheEntry = await this.readFromCache(this.getCacheKey(finalAssets, pipeline.configs));
    (0, _assert.default)(pipeline.postProcess != null);
    let processedFinalAssets = (_ref = (_processedCacheEntry = processedCacheEntry) !== null && _processedCacheEntry !== void 0 ? _processedCacheEntry : await pipeline.postProcess(assets)) !== null && _ref !== void 0 ? _ref : [];

    if (!processedCacheEntry) {
      await this.writeToCache(this.getCacheKey(processedFinalAssets, pipeline.configs), processedFinalAssets, pipeline.configs);
    }

    return processedFinalAssets;
  }

  async readFromCache(cacheKey) {
    if (this.options.disableCache || this.request.code != null) {
      return null;
    }

    let cachedAssets = await this.options.cache.get(cacheKey);

    if (!cachedAssets) {
      return null;
    }

    return cachedAssets.map(value => new _InternalAsset.default({
      value,
      options: this.options
    }));
  }

  async writeToCache(cacheKey, assets, configs) {
    await Promise.all( // TODO: account for impactfulOptions maybe being different per pipeline
    assets.map(asset => asset.commit((0, _utils.md5FromObject)({
      impactfulOptions: this.impactfulOptions,
      configs: getImpactfulConfigInfo(configs)
    }))));
    this.options.cache.set(cacheKey, assets.map(a => a.value));
  }

  getCacheKey(assets, configs) {
    let assetsKeyInfo = assets.map(a => ({
      filePath: a.value.filePath,
      hash: a.value.hash
    }));
    return (0, _utils.md5FromObject)({
      parcelVersion: _constants.PARCEL_VERSION,
      assets: assetsKeyInfo,
      configs: getImpactfulConfigInfo(configs),
      env: this.request.env,
      impactfulOptions: this.impactfulOptions
    });
  }

  async loadPipeline(filePath, isSource, pipelineName) {
    let configRequest = {
      filePath,
      env: this.request.env,
      isSource,
      pipeline: pipelineName,
      meta: {
        actionType: 'transformation'
      }
    };
    let configs = new Map();
    let config = await this.loadConfig(configRequest);
    let result = (0, _nullthrows.default)(config.result);
    let parcelConfig = new _ParcelConfig.default(config.result, this.options.packageManager);
    configs.set('parcel', config);

    for (let [moduleName] of config.devDeps) {
      let plugin = await parcelConfig.loadPlugin(moduleName); // TODO: implement loadPlugin in existing plugins that require config

      if (plugin.loadConfig) {
        let thirdPartyConfig = await this.loadTransformerConfig({
          filePath,
          plugin: moduleName,
          parcelConfigPath: result.filePath,
          isSource
        });
        let config = new _Config.default(thirdPartyConfig, this.options);

        if (thirdPartyConfig.shouldRehydrate) {
          await plugin.rehydrateConfig({
            config,
            options: this.options
          });
        } else if (thirdPartyConfig.shouldReload) {
          await plugin.loadConfig({
            config,
            options: this.options
          });
        }

        configs.set(moduleName, thirdPartyConfig);
      }
    }

    let pipeline = new Pipeline({
      names: parcelConfig.getTransformerNames(filePath, pipelineName),
      plugins: await parcelConfig.getTransformers(filePath, pipelineName),
      configs,
      options: this.options,
      workerApi: this.workerApi
    });
    return pipeline;
  }

  async loadNextPipeline({
    filePath,
    isSource,
    nextType,
    currentPipeline
  }) {
    let nextFilePath = filePath.slice(0, -_path.default.extname(filePath).length) + '.' + nextType;
    let nextPipeline = await this.loadPipeline(nextFilePath, isSource, this.request.pipeline);

    if (nextPipeline.id === currentPipeline.id) {
      return null;
    }

    return nextPipeline;
  }

  loadTransformerConfig({
    filePath,
    plugin,
    parcelConfigPath,
    isSource
  }) {
    let configRequest = {
      filePath,
      env: this.request.env,
      plugin,
      isSource,
      meta: {
        parcelConfigPath
      }
    };
    return this.loadConfig(configRequest);
  }

}

exports.default = Transformation;

class Pipeline {
  constructor({
    names,
    plugins,
    configs,
    options,
    workerApi
  }) {
    _defineProperty(this, "id", void 0);

    _defineProperty(this, "transformers", void 0);

    _defineProperty(this, "configs", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "pluginOptions", void 0);

    _defineProperty(this, "resolverRunner", void 0);

    _defineProperty(this, "generate", void 0);

    _defineProperty(this, "postProcess", void 0);

    _defineProperty(this, "workerApi", void 0);

    this.id = names.join(':');
    this.transformers = names.map((name, i) => {
      var _configs$get;

      return {
        name,
        config: (_configs$get = configs.get(name)) === null || _configs$get === void 0 ? void 0 : _configs$get.result,
        plugin: plugins[i]
      };
    });
    this.configs = configs;
    this.options = options;
    let parcelConfig = new _ParcelConfig.default((0, _nullthrows.default)((0, _nullthrows.default)(this.configs.get('parcel')).result), this.options.packageManager);
    this.resolverRunner = new _ResolverRunner.default({
      config: parcelConfig,
      options
    });
    this.pluginOptions = new _PluginOptions.default(this.options);
    this.workerApi = workerApi;
  }

  async transform(initialAsset) {
    let initialType = initialAsset.value.type;
    let inputAssets = [initialAsset];
    let resultingAssets;
    let finalAssets = [];

    for (let transformer of this.transformers) {
      resultingAssets = [];

      for (let asset of inputAssets) {
        // TODO: I think there may be a bug here if the type changes but does not
        // change pipelines (e.g. .html -> .htm). It should continue on the same
        // pipeline in that case.
        if (asset.value.type !== initialType) {
          finalAssets.push(asset);
        } else {
          let transformerResults = await this.runTransformer(asset, transformer.plugin, transformer.config);

          for (let result of transformerResults) {
            resultingAssets.push(asset.createChildAsset(result));
          }
        }
      }

      inputAssets = resultingAssets;
    }

    finalAssets = finalAssets.concat(resultingAssets);
    return Promise.all(finalAssets.map(asset => finalize((0, _nullthrows.default)(asset), this.generate)));
  }

  async runTransformer(asset, transformer, preloadedConfig) {
    const resolve = async (from, to) => {
      return (0, _nullthrows.default)((await this.resolverRunner.resolve((0, _Dependency.createDependency)({
        env: asset.value.env,
        moduleSpecifier: to,
        sourcePath: from
      })))).filePath;
    }; // Load config for the transformer.


    let config = preloadedConfig;

    if (transformer.getConfig) {
      // TODO: deprecate getConfig
      config = await transformer.getConfig({
        asset: new _Asset.MutableAsset(asset),
        options: this.pluginOptions,
        resolve
      });
    } // If an ast exists on the asset, but we cannot reuse it,
    // use the previous transform to generate code that we can re-parse.


    if (asset.ast && (!transformer.canReuseAST || !transformer.canReuseAST({
      ast: asset.ast,
      options: this.pluginOptions
    })) && this.generate) {
      let output = await this.generate(new _Asset.MutableAsset(asset));
      asset.content = output.code;
      asset.ast = null;
    } // Parse if there is no AST available from a previous transform.


    if (!asset.ast && transformer.parse) {
      asset.ast = await transformer.parse({
        asset: new _Asset.MutableAsset(asset),
        config,
        options: this.pluginOptions,
        resolve
      });
    } // Transform.


    let results = await normalizeAssets(( // $FlowFixMe
    await transformer.transform({
      asset: new _Asset.MutableAsset(asset),
      config,
      options: this.pluginOptions,
      resolve
    }))); // Create generate and postProcess functions that can be called later

    this.generate = input => {
      if (transformer.generate) {
        return Promise.resolve(transformer.generate({
          asset: input,
          config,
          options: this.pluginOptions,
          resolve
        }));
      }

      throw new Error('Asset has an AST but no generate method is available on the transform');
    }; // For Flow


    let postProcess = transformer.postProcess;

    if (postProcess) {
      this.postProcess = async assets => {
        let results = await postProcess.call(transformer, {
          assets: assets.map(asset => new _Asset.MutableAsset(asset)),
          config,
          options: this.pluginOptions,
          resolve
        });
        return Promise.all(results.map(result => asset.createChildAsset(result)));
      };
    }

    return results;
  }

}

async function finalize(asset, generate) {
  if (asset.ast && generate) {
    let result = await generate(new _Asset.MutableAsset(asset));
    return asset.createChildAsset(_objectSpread({
      type: asset.value.type,
      uniqueKey: asset.value.uniqueKey
    }, result));
  }

  return asset;
}

function normalizeAssets(results) {
  return results.map(result => {
    if (!(result instanceof _Asset.MutableAsset)) {
      return result;
    }

    let internalAsset = (0, _Asset.assetToInternalAsset)(result);
    return {
      type: result.type,
      content: internalAsset.content,
      ast: result.ast,
      map: internalAsset.map,
      // $FlowFixMe
      dependencies: [...internalAsset.value.dependencies.values()],
      includedFiles: result.getIncludedFiles(),
      // $FlowFixMe
      env: result.env,
      isIsolated: result.isIsolated,
      isInline: result.isInline,
      meta: result.meta,
      uniqueKey: internalAsset.value.uniqueKey
    };
  });
}

function getImpactfulConfigInfo(configs) {
  return [...configs].map(([, {
    resultHash,
    devDeps
  }]) => ({
    resultHash,
    devDeps: [...devDeps]
  }));
}