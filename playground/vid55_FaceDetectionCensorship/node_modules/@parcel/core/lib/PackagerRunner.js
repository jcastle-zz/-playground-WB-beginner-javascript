"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("@parcel/utils");

var _stream = require("stream");

var _assert = _interopRequireDefault(require("assert"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _path = _interopRequireDefault(require("path"));

var _url = _interopRequireDefault(require("url"));

var _Bundle = require("./public/Bundle");

var _ReporterRunner = require("./ReporterRunner");

var _BundleGraph = _interopRequireWildcard(require("./public/BundleGraph"));

var _PluginOptions = _interopRequireDefault(require("./public/PluginOptions"));

var _constants = require("./constants");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class PackagerRunner {
  constructor({
    config,
    farm,
    options
  }) {
    _defineProperty(this, "config", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "farm", void 0);

    _defineProperty(this, "pluginOptions", void 0);

    _defineProperty(this, "distDir", void 0);

    _defineProperty(this, "distExists", void 0);

    _defineProperty(this, "writeBundleFromWorker", void 0);

    this.config = config;
    this.options = options;
    this.pluginOptions = new _PluginOptions.default(this.options);
    this.farm = farm;
    this.writeBundleFromWorker = farm ? farm.createHandle('runPackage') : () => {
      throw new Error('Cannot call PackagerRunner.writeBundleFromWorker() in a worker');
    };
  }

  async writeBundles(bundleGraph) {
    let farm = (0, _nullthrows.default)(this.farm);
    let {
      ref,
      dispose
    } = await farm.createSharedReference(bundleGraph);
    let promises = [];

    for (let bundle of bundleGraph.getBundles()) {
      // skip inline bundles, they will be processed via the parent bundle
      if (bundle.isInline) {
        continue;
      }

      promises.push(this.writeBundle(bundle, bundleGraph, ref).then(stats => {
        bundle.stats = stats;
      }));
    }

    await Promise.all(promises);
    await dispose();
  }

  async writeBundle(bundle, bundleGraph, bundleGraphReference) {
    let start = Date.now();
    let cacheKey = await this.getCacheKey(bundle, bundleGraph);
    let {
      size
    } = (await this.writeBundleFromCache({
      bundle,
      bundleGraph,
      cacheKey
    })) || (await this.writeBundleFromWorker({
      bundle,
      cacheKey,
      bundleGraphReference,
      options: this.options,
      config: this.config
    }));
    return {
      time: Date.now() - start,
      size
    };
  }

  async writeBundleFromCache({
    bundle,
    bundleGraph,
    cacheKey
  }) {
    if (this.options.disableCache) {
      return;
    }

    let cacheResult = await this.readFromCache(cacheKey);

    if (cacheResult == null) {
      return;
    }

    let {
      contents,
      map
    } = cacheResult;
    let {
      size
    } = await this.writeToDist({
      bundle,
      bundleGraph,
      contents,
      map
    });
    return {
      size
    };
  }

  async packageAndWriteBundle(bundle, bundleGraph, cacheKey) {
    let start = Date.now();
    let {
      contents,
      map
    } = await this.getBundleResult(bundle, bundleGraph, cacheKey);
    let {
      size
    } = await this.writeToDist({
      bundle,
      bundleGraph,
      contents,
      map
    });
    return {
      time: Date.now() - start,
      size
    };
  }

  async getBundleResult(bundle, bundleGraph, cacheKey) {
    let result;

    if (!cacheKey && !this.options.disableCache) {
      cacheKey = await this.getCacheKey(bundle, bundleGraph);
      let cacheResult = await this.readFromCache(cacheKey);

      if (cacheResult) {
        // NOTE: Returning a new object for flow
        return {
          contents: cacheResult.contents,
          map: cacheResult.map
        };
      }
    }

    let packaged = await this.package(bundle, bundleGraph);
    let res = await this.optimize(bundle, bundleGraph, packaged.contents, packaged.map);
    let map = res.map ? await this.generateSourceMap(bundle, res.map) : null;
    result = {
      contents: res.contents,
      map
    };

    if (cacheKey != null) {
      await this.writeToCache(cacheKey, result.contents, map);

      if (result.contents instanceof _stream.Readable) {
        return {
          contents: this.options.cache.getStream(getContentKey(cacheKey)),
          map: result.map
        };
      }
    }

    return result;
  }

  async package(internalBundle, bundleGraph) {
    let bundle = new _Bundle.NamedBundle(internalBundle, bundleGraph, this.options);
    (0, _ReporterRunner.report)({
      type: 'buildProgress',
      phase: 'packaging',
      bundle
    });
    let packager = await this.config.getPackager(bundle.filePath);
    let packaged = await packager.package({
      bundle,
      bundleGraph: new _BundleGraph.default(bundleGraph, this.options),
      getSourceMapReference: map => {
        return bundle.isInline || bundle.target.sourceMap && bundle.target.sourceMap.inline ? this.generateSourceMap((0, _Bundle.bundleToInternalBundle)(bundle), map) : _path.default.basename(bundle.filePath) + '.map';
      },
      options: this.pluginOptions,
      getInlineBundleContents: (bundle, bundleGraph) => {
        if (!bundle.isInline) {
          throw new Error('Bundle is not inline and unable to retrieve contents');
        }

        return this.getBundleResult((0, _Bundle.bundleToInternalBundle)(bundle), (0, _BundleGraph.bundleGraphToInternalBundleGraph)(bundleGraph));
      }
    });
    return {
      contents: typeof packaged.contents === 'string' ? replaceReferences(packaged.contents, generateDepToBundlePath(internalBundle, bundleGraph)) : packaged.contents,
      map: packaged.map
    };
  }

  async optimize(internalBundle, bundleGraph, contents, map) {
    let bundle = new _Bundle.NamedBundle(internalBundle, bundleGraph, this.options);
    let optimizers = await this.config.getOptimizers(bundle.filePath);

    if (!optimizers.length) {
      return {
        contents,
        map
      };
    }

    (0, _ReporterRunner.report)({
      type: 'buildProgress',
      phase: 'optimizing',
      bundle
    });
    let optimized = {
      contents,
      map
    };

    for (let optimizer of optimizers) {
      optimized = await optimizer.optimize({
        bundle,
        contents: optimized.contents,
        map: optimized.map,
        options: this.pluginOptions
      });
    }

    return optimized;
  }

  generateSourceMap(bundle, map) {
    // sourceRoot should be a relative path between outDir and rootDir for node.js targets
    let filePath = (0, _nullthrows.default)(bundle.filePath);

    let sourceRoot = _path.default.relative(_path.default.dirname(filePath), this.options.projectRoot);

    let inlineSources = false;

    if (bundle.target) {
      if (bundle.target.sourceMap && bundle.target.sourceMap.sourceRoot !== undefined) {
        sourceRoot = bundle.target.sourceMap.sourceRoot;
      } else if (bundle.target.env.context === 'browser' && this.options.mode !== 'production') {
        sourceRoot = '/__parcel_source_root';
      }

      if (bundle.target.sourceMap && bundle.target.sourceMap.inlineSources !== undefined) {
        inlineSources = bundle.target.sourceMap.inlineSources;
      } else if (bundle.target.env.context !== 'node') {
        // inlining should only happen in production for browser targets by default
        inlineSources = this.options.mode === 'production';
      }
    }

    return map.stringify({
      file: _path.default.basename(filePath + '.map'),
      fs: this.options.inputFS,
      rootDir: this.options.projectRoot,
      sourceRoot: !inlineSources ? _url.default.format(_url.default.parse(sourceRoot + '/')) : undefined,
      inlineSources,
      inlineMap: bundle.isInline || bundle.target.sourceMap && bundle.target.sourceMap.inline
    });
  }

  getCacheKey(bundle, bundleGraph) {
    let filePath = (0, _nullthrows.default)(bundle.filePath); // TODO: include packagers and optimizers used in inline bundles as well

    let packager = this.config.getPackagerName(filePath);
    let optimizers = this.config.getOptimizerNames(filePath);
    let deps = Promise.all([packager, ...optimizers].map(async pkg => {
      let {
        pkg: resolvedPkg
      } = await this.options.packageManager.resolve(`${pkg}/package.json`, `${this.config.filePath}/index`);
      let version = (0, _nullthrows.default)(resolvedPkg).version;
      return [pkg, version];
    })); // TODO: add third party configs to the cache key

    let {
      minify,
      scopeHoist,
      sourceMaps
    } = this.options;
    return (0, _utils.md5FromObject)({
      parcelVersion: _constants.PARCEL_VERSION,
      deps,
      opts: {
        minify,
        scopeHoist,
        sourceMaps
      },
      hash: bundleGraph.getHash(bundle)
    });
  }

  async readFromCache(cacheKey) {
    let contentKey = getContentKey(cacheKey);
    let mapKey = getMapKey(cacheKey);
    let contentExists = await this.options.cache.blobExists(contentKey);

    if (!contentExists) {
      return null;
    }

    let mapExists = await this.options.cache.blobExists(mapKey);
    return {
      contents: this.options.cache.getStream(contentKey),
      map: mapExists ? this.options.cache.getStream(mapKey) : null
    };
  }

  async writeToDist({
    bundle,
    bundleGraph,
    contents,
    map
  }) {
    let {
      inputFS,
      outputFS
    } = this.options;
    let filePath = (0, _nullthrows.default)(bundle.filePath);

    let dir = _path.default.dirname(filePath);

    await outputFS.mkdirp(dir); // ? Got rid of dist exists, is this an expensive operation
    // Use the file mode from the entry asset as the file mode for the bundle.
    // Don't do this for browser builds, as the executable bit in particular is unnecessary.

    let publicBundle = new _Bundle.NamedBundle(bundle, bundleGraph, this.options);
    let writeOptions = publicBundle.env.isBrowser() ? undefined : {
      mode: (await inputFS.stat((0, _nullthrows.default)(publicBundle.getMainEntry()).filePath)).mode
    };
    let size;

    if (contents instanceof _stream.Readable) {
      size = await writeFileStream(outputFS, filePath, contents, writeOptions);
    } else {
      await outputFS.writeFile(filePath, contents, writeOptions);
      size = contents.length;
    }

    if (map != null) {
      if (map instanceof _stream.Readable) {
        await writeFileStream(outputFS, filePath + '.map', map);
      } else {
        await outputFS.writeFile(filePath + '.map', map);
      }
    }

    return {
      size
    };
  }

  async writeToCache(cacheKey, contents, map) {
    let contentKey = getContentKey(cacheKey);
    await this.options.cache.setStream(contentKey, (0, _utils.blobToStream)(contents));

    if (map != null) {
      let mapKey = getMapKey(cacheKey);
      await this.options.cache.setStream(mapKey, (0, _utils.blobToStream)(map));
    }
  }

}

exports.default = PackagerRunner;

function writeFileStream(fs, filePath, stream, options) {
  return new Promise((resolve, reject) => {
    let fsStream = fs.createWriteStream(filePath, options);
    stream.pipe(fsStream) // $FlowFixMe
    .on('finish', () => resolve(fsStream.bytesWritten)).on('error', reject);
  });
}
/*
 * Build a mapping from async, url dependency ids to web-friendly relative paths
 * to their bundles. These will be relative to the current bundle if `publicUrl`
 * is not provided. If `publicUrl` is provided, the paths will be joined to it.
 *
 * These are used to translate any placeholder dependency ids written during
 * transformation back to a path that can be loaded in a browser (such as
 * in a "raw" loader or any transformed dependencies referred to by url).
 */


function generateDepToBundlePath(bundle, bundleGraph) {
  let depToBundlePath = new Map();
  bundleGraph.traverseBundle(bundle, node => {
    var _nullthrows$publicUrl;

    if (node.type !== 'dependency') {
      return;
    }

    let dep = node.value;

    if (!dep.isURL || !dep.isAsync) {
      return;
    }

    let [bundleGroupNode] = bundleGraph._graph.getNodesConnectedFrom(node);

    (0, _assert.default)(bundleGroupNode && bundleGroupNode.type === 'bundle_group');

    let [entryBundleNode] = bundleGraph._graph.getNodesConnectedFrom(bundleGroupNode, 'bundle');

    (0, _assert.default)(entryBundleNode && entryBundleNode.type === 'bundle');
    let entryBundle = entryBundleNode.value;
    depToBundlePath.set(dep.id, (0, _utils.urlJoin)((_nullthrows$publicUrl = (0, _nullthrows.default)(entryBundle.target).publicUrl) !== null && _nullthrows$publicUrl !== void 0 ? _nullthrows$publicUrl : '/', (0, _nullthrows.default)(entryBundle.name)));
  });
  return depToBundlePath;
} // replace references to url dependencies with relative paths to their
// corresponding bundles.
// TODO: This likely alters the length of the column in the source text.
//       Update any sourcemaps accordingly.


function replaceReferences(code, depToBundlePath) {
  let output = code;

  for (let [depId, replacement] of depToBundlePath) {
    let split = output.split(depId);

    if (split.length > 1) {
      // the dependency id was found in the text. replace it.
      output = split.join(replacement);
    }
  }

  return output;
}

function getContentKey(cacheKey) {
  return (0, _utils.md5FromString)(`${cacheKey}:content`);
}

function getMapKey(cacheKey) {
  return (0, _utils.md5FromString)(`${cacheKey}:map`);
}