"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BuildAbortError = exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _utils = require("@parcel/utils");

var _AssetGraph = _interopRequireDefault(require("./AssetGraph"));

var _RequestGraph = _interopRequireDefault(require("./RequestGraph"));

var _constants = require("./constants");

var _dumpGraphToGraphViz = _interopRequireDefault(require("./dumpGraphToGraphViz"));

var _path = _interopRequireDefault(require("path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class AssetGraphBuilder extends _events.default {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "assetGraph", void 0);

    _defineProperty(this, "requestGraph", void 0);

    _defineProperty(this, "controller", void 0);

    _defineProperty(this, "changedAssets", new Map());

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "cacheKey", void 0);
  }

  async init({
    config,
    options,
    entries,
    name,
    assetRequests,
    workerFarm
  }) {
    this.options = options;
    let {
      minify,
      hot,
      scopeHoist
    } = options;
    this.cacheKey = (0, _utils.md5FromObject)({
      parcelVersion: _constants.PARCEL_VERSION,
      name,
      options: {
        minify,
        hot,
        scopeHoist
      },
      entries
    });
    let changes = await this.readFromCache();

    if (!changes) {
      this.assetGraph = new _AssetGraph.default();
      this.requestGraph = new _RequestGraph.default();
    }

    this.assetGraph.initOptions({
      onNodeAdded: node => this.handleNodeAddedToAssetGraph(node),
      onNodeRemoved: node => this.handleNodeRemovedFromAssetGraph(node)
    });
    this.requestGraph.initOptions({
      config,
      options,
      onEntryRequestComplete: this.handleCompletedEntryRequest.bind(this),
      onTargetRequestComplete: this.handleCompletedTargetRequest.bind(this),
      onAssetRequestComplete: this.handleCompletedAssetRequest.bind(this),
      onDepPathRequestComplete: this.handleCompletedDepPathRequest.bind(this),
      workerFarm
    });

    if (changes) {
      this.requestGraph.invalidateUnpredictableNodes();
      this.respondToFSEvents(changes);
    } else {
      this.assetGraph.initialize({
        entries,
        assetGroups: assetRequests
      });
    }
  }

  async build() {
    await this.requestGraph.completeRequests();
    (0, _dumpGraphToGraphViz.default)(this.assetGraph, 'AssetGraph');
    (0, _dumpGraphToGraphViz.default)(this.requestGraph, 'RequestGraph');
    let changedAssets = this.changedAssets;
    this.changedAssets = new Map();
    return {
      assetGraph: this.assetGraph,
      changedAssets: changedAssets
    };
  }

  validate() {
    return this.requestGraph.completeValidations();
  }

  handleNodeAddedToAssetGraph(node) {
    switch (node.type) {
      case 'entry_specifier':
        this.requestGraph.addEntryRequest(node.value);
        break;

      case 'entry_file':
        this.requestGraph.addTargetRequest(node.value);
        break;

      case 'dependency':
        this.requestGraph.addDepPathRequest(node.value);
        break;

      case 'asset_group':
        this.requestGraph.addAssetRequest(node.id, node.value);
        break;

      case 'asset':
        {
          let asset = node.value;
          this.changedAssets.set(asset.id, asset); // ? Is this right?

          break;
        }
    }
  }

  handleNodeRemovedFromAssetGraph(node) {
    switch (node.type) {
      case 'dependency':
      case 'asset_group':
        this.requestGraph.removeById(node.id);
        break;

      case 'entry_specifier':
        this.requestGraph.removeById('entry_request:' + node.value);
        break;

      case 'entry_file':
        this.requestGraph.removeById('target_request:' + node.value);
        break;
    }
  }

  handleCompletedEntryRequest(entry, resolved) {
    this.assetGraph.resolveEntry(entry, resolved);
  }

  handleCompletedTargetRequest(entryFile, targets) {
    this.assetGraph.resolveTargets(entryFile, targets);
  }

  handleCompletedAssetRequest(requestNode, assets) {
    this.assetGraph.resolveAssetGroup(requestNode.value, assets);

    for (let asset of assets) {
      this.changedAssets.set(asset.id, asset); // ? Is this right?
    }
  }

  handleCompletedDepPathRequest(requestNode, result) {
    this.assetGraph.resolveDependency(requestNode.value, result);
  }

  respondToFSEvents(events) {
    return this.requestGraph.respondToFSEvents(events);
  }

  getWatcherOptions() {
    let vcsDirs = ['.git', '.hg'].map(dir => _path.default.join(this.options.projectRoot, dir));
    let ignore = [this.options.cacheDir, ...vcsDirs];
    return {
      ignore
    };
  }

  getCacheKeys() {
    let assetGraphKey = (0, _utils.md5FromString)(`${this.cacheKey}:assetGraph`);
    let requestGraphKey = (0, _utils.md5FromString)(`${this.cacheKey}:requestGraph`);
    let snapshotKey = (0, _utils.md5FromString)(`${this.cacheKey}:snapshot`);
    return {
      assetGraphKey,
      requestGraphKey,
      snapshotKey
    };
  }

  async readFromCache() {
    if (this.options.disableCache) {
      return null;
    }

    let {
      assetGraphKey,
      requestGraphKey,
      snapshotKey
    } = this.getCacheKeys();
    let assetGraph = await this.options.cache.get(assetGraphKey);
    let requestGraph = await this.options.cache.get(requestGraphKey);

    if (assetGraph && requestGraph) {
      this.assetGraph = assetGraph;
      this.requestGraph = requestGraph;
      let opts = this.getWatcherOptions();

      let snapshotPath = this.options.cache._getCachePath(snapshotKey, '.txt');

      return this.options.inputFS.getEventsSince(this.options.projectRoot, snapshotPath, opts);
    }

    return null;
  }

  async writeToCache() {
    if (this.options.disableCache) {
      return;
    }

    let {
      assetGraphKey,
      requestGraphKey,
      snapshotKey
    } = this.getCacheKeys();
    await this.options.cache.set(assetGraphKey, this.assetGraph);
    await this.options.cache.set(requestGraphKey, this.requestGraph);
    let opts = this.getWatcherOptions();

    let snapshotPath = this.options.cache._getCachePath(snapshotKey, '.txt');

    await this.options.inputFS.writeSnapshot(this.options.projectRoot, snapshotPath, opts);
  }

}

exports.default = AssetGraphBuilder;

class BuildAbortError extends Error {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "name", 'BuildAbortError');
  }

}

exports.BuildAbortError = BuildAbortError;