"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateBundleImports = generateBundleImports;
exports.generateExternalImport = generateExternalImport;
exports.generateExports = generateExports;

var t = _interopRequireWildcard(require("@babel/types"));

var _utils = require("@parcel/utils");

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _assert = _interopRequireDefault(require("assert"));

var _renamer = _interopRequireDefault(require("../renamer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function generateBundleImports(from, bundle, assets) {
  let specifiers = [...assets].map(asset => {
    let id = t.identifier(asset.meta.exportsIdentifier);
    return t.importSpecifier(id, id);
  });
  return [t.importDeclaration(specifiers, t.stringLiteral((0, _utils.relativeBundlePath)(from, bundle)))];
}

function generateExternalImport(bundle, source, specifiers) {
  let defaultSpecifier = null;
  let namespaceSpecifier = null;
  let namedSpecifiers = [];

  for (let [imported, symbol] of specifiers) {
    if (imported === 'default') {
      defaultSpecifier = t.importDefaultSpecifier(t.identifier(symbol));
    } else if (imported === '*') {
      namespaceSpecifier = t.importNamespaceSpecifier(t.identifier(symbol));
    } else {
      namedSpecifiers.push(t.importSpecifier(t.identifier(symbol), t.identifier(imported)));
    }
  }

  let statements = []; // ESModule syntax allows combining default and namespace specifiers, or default and named, but not all three.

  if (namespaceSpecifier) {
    let s = [namespaceSpecifier];

    if (defaultSpecifier) {
      s.unshift(defaultSpecifier);
    }

    statements.push(t.importDeclaration(s, t.stringLiteral(source)));
  } else if (defaultSpecifier) {
    namedSpecifiers.unshift(defaultSpecifier);
  }

  if (namedSpecifiers.length > 0 || statements.length === 0) {
    statements.push(t.importDeclaration(namedSpecifiers, t.stringLiteral(source)));
  }

  return statements;
}

function generateExports(bundleGraph, bundle, referencedAssets, path) {
  let exportedIdentifiers = new Map();
  let entry = bundle.getMainEntry();

  if (entry) {
    for (let _ref of bundleGraph.getExportedSymbols(entry)) {
      let {
        exportSymbol,
        symbol
      } = _ref;

      // If there is an existing binding with the exported name (e.g. an import),
      // rename it so we can use the name for the export instead.
      if (path.scope.hasBinding(exportSymbol)) {
        (0, _renamer.default)(path.scope, exportSymbol, path.scope.generateUid(exportSymbol));
      }

      exportedIdentifiers.set(symbol, exportSymbol);
    }
  }

  for (let asset of referencedAssets) {
    let exportsId = asset.meta.exportsIdentifier;
    (0, _assert.default)(typeof exportsId === 'string');
    exportedIdentifiers.set(exportsId, exportsId);
  }

  let exported = new Set();
  path.traverse({
    Declaration(path) {
      if (path.isExportDeclaration() || path.parentPath.isExportDeclaration() || path.isImportDeclaration()) {
        return;
      }

      let bindingIdentifiers = path.getBindingIdentifierPaths(false, true);
      let ids = Object.keys(bindingIdentifiers);
      let exportedIds = ids.filter(id => exportedIdentifiers.has(id) && exportedIdentifiers.get(id) !== 'default');
      let defaultExport = ids.find(id => exportedIdentifiers.get(id) === 'default'); // If all exports in the binding are named exports, export the entire declaration.
      // Also rename all of the identifiers to their exported name.

      if (exportedIds.length === ids.length) {
        path.replaceWith(t.exportNamedDeclaration(path.node, []));

        for (let id of exportedIds) {
          let exportName = (0, _nullthrows.default)(exportedIdentifiers.get(id));
          (0, _renamer.default)(path.scope, id, exportName);
          exported.add(exportName);
        } // If there is only a default export, export the entire declaration.

      } else if (ids.length === 1 && defaultExport && !path.isVariableDeclaration()) {
        path.replaceWith(t.exportDefaultDeclaration(path.node)); // Otherwise, add export statements after for each identifier.
      } else {
        if (defaultExport) {
          path.insertAfter(t.exportDefaultDeclaration(t.identifier(defaultExport)));
        }

        if (exportedIds.length > 0) {
          let specifiers = [];

          for (let id of exportedIds) {
            let exportName = (0, _nullthrows.default)(exportedIdentifiers.get(id));
            (0, _renamer.default)(path.scope, id, exportName);
            exported.add(exportName);
            specifiers.push(t.exportSpecifier(t.identifier(exportName), t.identifier(exportName)));
          }

          path.insertAfter(t.exportNamedDeclaration(null, specifiers));
        }
      }
    }

  });
  return exported;
}