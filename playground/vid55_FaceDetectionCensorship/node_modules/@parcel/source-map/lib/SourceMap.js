"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sourceMap = require("source-map");

var _utils = require("@parcel/utils");

var _path = _interopRequireDefault(require("path"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

var _package = _interopRequireDefault(require("../package.json"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { keys.push.apply(keys, Object.getOwnPropertySymbols(object)); } if (enumerableOnly) keys = keys.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function generateInlineMap(map) {
  return `data:application/json;charset=utf-8;base64,${new Buffer(map).toString('base64')}`;
}

class SourceMap {
  constructor(mappings = [], sources = {}) {
    _defineProperty(this, "mappings", void 0);

    _defineProperty(this, "sources", void 0);

    _defineProperty(this, "linecount", void 0);

    this.mappings = mappings;
    this.sources = sources;
  }

  static deserialize(opts) {
    return new SourceMap(opts.mappings, opts.sources);
  }

  serialize() {
    return {
      mappings: this.mappings,
      sources: this.sources
    };
  } // Static Helper functions


  static generateEmptyMap(sourceName, sourceContent) {
    let map = new SourceMap();
    map.setSourceContentFor(sourceName, sourceContent);
    let lineCount = (0, _utils.countLines)(sourceContent);

    for (let line = 1; line < lineCount + 1; line++) {
      map.addMapping({
        source: sourceName,
        original: {
          line: line,
          column: 0
        },
        generated: {
          line: line,
          column: 0
        }
      });
    }

    map.linecount = lineCount;
    return map;
  }

  static async fromRawSourceMap(input) {
    let map = new SourceMap();
    await map.addRawMap(input);
    return map;
  }

  getConsumer(map) {
    if (map instanceof _sourceMap.SourceMapConsumer) {
      return Promise.resolve(map);
    }

    let sourcemap = typeof map === 'string' ? JSON.parse(map) : map;

    if (sourcemap.sourceRoot != null) {
      // $FlowFixMe
      delete sourcemap.sourceRoot;
    }

    return new _sourceMap.SourceMapConsumer(sourcemap);
  }

  async addRawMap(map, lineOffset = 0, columnOffset = 0) {
    let consumer = await this.getConsumer(map);
    consumer.eachMapping(mapping => {
      // $FlowFixMe line value < 1 is invalid so this should be fine...
      if (mapping.originalLine) {
        this.addConsumerMapping(mapping, lineOffset, columnOffset);

        if (!this.sourceContentFor(mapping.source)) {
          this.setSourceContentFor(mapping.source, consumer.sourceContentFor(mapping.source, true));
        }
      }
    });
    consumer.destroy();
    return this;
  }

  addMap(map, lineOffset = 0, columnOffset = 0) {
    if (lineOffset === 0 && columnOffset === 0) {
      this.mappings.push(...map.mappings);
    } else {
      map.eachMapping(mapping => {
        this.addMapping(mapping, lineOffset, columnOffset);
      });
    }

    for (let key of Object.keys(map.sources)) {
      if (!this.sourceContentFor(key)) {
        this.setSourceContentFor(key, map.sourceContentFor(key));
      }
    }

    return this;
  }

  addMapping(mapping, lineOffset = 0, columnOffset = 0) {
    if (mapping.original) {
      this.mappings.push({
        source: mapping.source,
        name: mapping.name,
        original: mapping.original,
        generated: {
          line: mapping.generated.line + lineOffset,
          column: mapping.generated.column + columnOffset
        }
      });
    } else {
      this.mappings.push({
        generated: {
          line: mapping.generated.line + lineOffset,
          column: mapping.generated.column + columnOffset
        }
      });
    }
  }

  addConsumerMapping(mapping, lineOffset = 0, columnOffset = 0) {
    // $FlowFixMe a line value of 0 is invalid so this should be fine...
    if (mapping.originalLine) {
      this.mappings.push({
        source: mapping.source,
        name: mapping.name,
        original: {
          line: mapping.originalLine,
          column: mapping.originalColumn
        },
        generated: {
          line: mapping.generatedLine + lineOffset,
          column: mapping.generatedColumn + columnOffset
        }
      });
    } else {
      this.mappings.push({
        generated: {
          line: mapping.generatedLine + lineOffset,
          column: mapping.generatedColumn + columnOffset
        }
      });
    }
  }

  eachMapping(callback) {
    this.mappings.forEach(callback);
  }

  async extend(extension) {
    let sourceMap = extension instanceof SourceMap ? extension : await new SourceMap().addRawMap(extension);
    return this._extend(sourceMap);
  }

  _extend(extension) {
    extension.eachMapping(mapping => {
      let originalMappingIndex = null;

      if (mapping.original != null) {
        originalMappingIndex = this.findClosest(mapping.original.line, mapping.original.column);
      }

      if (originalMappingIndex === null) {
        this.addMapping(mapping);
      } else {
        let originalMapping = this.mappings[originalMappingIndex];

        if (originalMapping.original) {
          this.mappings[originalMappingIndex] = {
            generated: mapping.generated,
            original: originalMapping.original,
            source: originalMapping.source,
            name: originalMapping.name
          };
        } else {
          this.mappings[originalMappingIndex] = {
            generated: mapping.generated
          };
        }
      }

      if (mapping.source != null && !this.sourceContentFor(mapping.source)) {
        this.setSourceContentFor(mapping.source, extension.sourceContentFor(mapping.source));
      }
    });
    return this;
  }

  findClosest(line, column) {
    if (line < 1) {
      throw new Error('Line numbers must be >= 1');
    }

    if (column < 0) {
      throw new Error('Column numbers must be >= 0');
    }

    if (this.mappings.length < 1) {
      return null;
    }

    var startIndex = 0;
    var stopIndex = this.mappings.length - 1;
    var middleIndex = Math.floor((stopIndex + startIndex) / 2);

    while (startIndex < stopIndex && this.mappings[middleIndex].generated.line !== line) {
      if (line < this.mappings[middleIndex].generated.line) {
        stopIndex = middleIndex - 1;
      } else if (line > this.mappings[middleIndex].generated.line) {
        startIndex = middleIndex + 1;
      }

      middleIndex = Math.floor((stopIndex + startIndex) / 2);
    }

    var mapping = this.mappings[middleIndex];

    if (!mapping || mapping.generated.line !== line) {
      return middleIndex;
    }

    while (middleIndex > 0 && this.mappings[middleIndex - 1].generated.line !== line) {
      middleIndex--;
    }

    while (middleIndex < this.mappings.length - 1 && this.mappings[middleIndex + 1].generated.line === line && this.mappings[middleIndex + 1].generated.column <= column) {
      middleIndex++;
    }

    return middleIndex;
  }

  originalPositionFor(generatedPosition) {
    let index = this.findClosest(generatedPosition.line, generatedPosition.column);

    if (index === null) {
      return {
        source: null,
        name: null,
        line: null,
        column: null
      };
    }

    let mapping = this.mappings[index];

    if (mapping.original) {
      let result = {
        source: mapping.source,
        name: typeof mapping.name === 'string' ? mapping.name : null,
        line: mapping.original.line,
        column: mapping.original.column
      };
      return result;
    } else {
      return {
        source: null,
        name: null,
        line: null,
        column: null
      };
    }
  }

  sourceContentFor(fileName) {
    return this.sources[fileName];
  }

  setSourceContentFor(fileName, sourceContent) {
    this.sources[fileName] = sourceContent;
  }

  offset(lineOffset = 0, columnOffset = 0) {
    this.mappings.map(mapping => _objectSpread({}, mapping, {
      generated: {
        line: mapping.generated.line + lineOffset,
        column: mapping.generated.column + columnOffset
      }
    }));
  }

  async stringify({
    file,
    sourceRoot,
    rootDir,
    inlineSources,
    fs,
    inlineMap
  }) {
    let generator = new _sourceMap.SourceMapGenerator({
      file,
      sourceRoot
    });
    this.eachMapping(mapping => {
      generator.addMapping(mapping);
    });

    if (inlineSources) {
      for (let sourceName of Object.keys(this.sources)) {
        let sourceContent = this.sourceContentFor(sourceName);

        if (sourceContent !== null) {
          generator.setSourceContent(sourceName, sourceContent);
        } else {
          try {
            let content = await (0, _nullthrows.default)(fs).readFile(_path.default.join(rootDir || '', sourceName), 'utf8');

            if (content) {
              generator.setSourceContent(sourceName, content);
            }
          } catch (e) {// do nothing
          }
        }
      }
    }

    let stringifiedMap = generator.toString();
    return inlineMap ? generateInlineMap(stringifiedMap) : stringifiedMap;
  }

}

exports.default = SourceMap;
(0, _utils.registerSerializableClass)(`${_package.default.version}:SourceMap`, SourceMap);