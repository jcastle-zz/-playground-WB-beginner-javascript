"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _path = _interopRequireDefault(require("path"));

var _http = _interopRequireDefault(require("http"));

var _https = _interopRequireDefault(require("https"));

var _url = _interopRequireWildcard(require("url"));

var _ansiHtml = _interopRequireDefault(require("ansi-html"));

var _logger = _interopRequireDefault(require("@parcel/logger"));

var _utils = require("@parcel/utils");

var _serverErrors = _interopRequireDefault(require("./serverErrors"));

var _fs = _interopRequireDefault(require("fs"));

var _ejs = _interopRequireDefault(require("ejs"));

var _connect = _interopRequireDefault(require("connect"));

var _httpProxyMiddleware = _interopRequireDefault(require("http-proxy-middleware"));

var _mime = _interopRequireDefault(require("mime"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function setHeaders(res) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, HEAD, PUT, PATCH, POST, DELETE');
  res.setHeader('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Content-Type');
}

const SOURCES_ENDPOINT = '/__parcel_source_root';

const TEMPLATE_404 = _fs.default.readFileSync(_path.default.join(__dirname, 'templates/404.html'), 'utf8');

const TEMPLATE_500 = _fs.default.readFileSync(_path.default.join(__dirname, 'templates/500.html'), 'utf8');

class Server extends _events.default {
  constructor(options) {
    super();

    _defineProperty(this, "pending", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "rootPath", void 0);

    _defineProperty(this, "bundleGraph", void 0);

    _defineProperty(this, "error", void 0);

    _defineProperty(this, "server", void 0);

    this.options = options;

    try {
      this.rootPath = new _url.URL(options.publicUrl).pathname;
    } catch (e) {
      this.rootPath = options.publicUrl;
    }

    this.pending = true;
    this.bundleGraph = null;
    this.error = null;
  }

  buildSuccess(bundleGraph) {
    this.bundleGraph = bundleGraph;
    this.error = null;
    this.pending = false;
    this.emit('bundled');
  }

  buildError(error) {
    this.error = error;
  }

  respond(req, res) {
    let {
      pathname
    } = _url.default.parse(req.originalUrl || req.url);

    if (this.error) {
      return this.send500(req, res);
    } else if (!pathname || this.rootPath != null && !pathname.startsWith(this.rootPath) || _path.default.extname(pathname) === '') {
      // If the URL doesn't start with the public path, or the URL doesn't
      // have a file extension, send the main HTML bundle.
      return this.sendIndex(req, res);
    } else if (pathname.startsWith(SOURCES_ENDPOINT)) {
      req.url = pathname.slice(SOURCES_ENDPOINT.length);
      return this.serve(this.options.inputFS, this.options.projectRoot, req, res, () => this.send404(req, res));
    } else {
      // Otherwise, serve the file from the dist folder
      req.url = this.rootPath ? pathname.slice(this.rootPath.length) : pathname;
      return this.serveDist(req, res, () => this.sendIndex(req, res));
    }
  }

  sendIndex(req, res) {
    if (this.bundleGraph) {
      // If the main asset is an HTML file, serve it
      let htmlBundle = null;
      this.bundleGraph.traverseBundles((bundle, context, {
        stop
      }) => {
        if (bundle.type !== 'html' || !bundle.isEntry) return;

        if (!htmlBundle) {
          htmlBundle = bundle;
        }

        if (htmlBundle && bundle.filePath && bundle.filePath.endsWith('index.html')) {
          htmlBundle = bundle;
          stop();
        }
      });

      if (htmlBundle) {
        req.url = `/${_path.default.basename(htmlBundle.filePath)}`;
        this.serveDist(req, res, () => this.send404(req, res));
      } else {
        this.send404(req, res);
      }
    } else {
      this.send404(req, res);
    }
  }

  serveDist(req, res, next) {
    return this.serve(this.options.outputFS, this.options.distDir, req, res, next);
  }

  async serve(fs, root, req, res, next) {
    if (req.method !== 'GET' && req.method !== 'HEAD') {
      // method not allowed
      res.statusCode = 405;
      res.setHeader('Allow', 'GET, HEAD');
      res.setHeader('Content-Length', '0');
      res.end();
      return;
    }

    try {
      var filePath = _url.default.parse(req.url).pathname || '';
      filePath = decodeURIComponent(filePath);
    } catch (err) {
      return this.sendError(res, 400);
    }

    if (filePath) {
      filePath = _path.default.normalize('.' + _path.default.sep + filePath);
    } // malicious path


    if (filePath.includes(_path.default.sep + '..' + _path.default.sep)) {
      return this.sendError(res, 403);
    } // join / normalize from the root dir


    filePath = _path.default.normalize(_path.default.join(root, filePath));

    try {
      var stat = await fs.stat(filePath);
    } catch (err) {
      if (err.code === 'ENOENT') {
        return next(req, res);
      }

      return this.sendError(res, 500);
    } // Fall back to next handler if not a file


    if (!stat || !stat.isFile()) {
      return next(req, res);
    }

    setHeaders(res);
    res.setHeader('Content-Length', '' + stat.size);
    res.setHeader('Content-Type', _mime.default.getType(filePath));

    if (req.method === 'HEAD') {
      res.end();
      return;
    }

    return new Promise((resolve, reject) => {
      fs.createReadStream(filePath).pipe(res).on('finish', resolve).on('error', reject);
    });
  }

  sendError(res, statusCode) {
    res.statusCode = statusCode;
    setHeaders(res);
    res.end();
  }

  send404(req, res) {
    res.statusCode = 404;
    setHeaders(res);
    res.end(TEMPLATE_404);
  }

  send500(req, res) {
    setHeaders(res);
    res.setHeader('Content-Type', 'text/html; charset=utf-8');
    res.writeHead(500);

    if (this.error) {
      let error = (0, _utils.prettyError)(this.error, {
        color: true
      });
      error.message = (0, _ansiHtml.default)(error.message);
      error.stack = (0, _ansiHtml.default)(error.stack);
      res.end(_ejs.default.render(TEMPLATE_500, {
        error
      }));
    } else {
      res.end();
    }
  }

  logAccessIfVerbose(req) {
    _logger.default.verbose(`Request: ${req.headers.host}${req.originalUrl || req.url}`);
  }
  /**
   * Load proxy table from package.json and apply them.
   */


  async applyProxyTable(app) {
    // avoid skipping project root
    const fileInRoot = _path.default.join(this.options.projectRoot, '_');

    const pkg = await (0, _utils.loadConfig)(this.options.inputFS, fileInRoot, ['.proxyrc.js', '.proxyrc']);

    if (!pkg || !pkg.config || !pkg.files) {
      return this;
    }

    const cfg = pkg.config;

    const filename = _path.default.basename(pkg.files[0].filePath);

    if (filename === '.proxyrc.js') {
      if (typeof cfg !== 'function') {
        _logger.default.warn("Proxy configuration file '.proxyrc.js' should export a function. Skipping...");

        return this;
      }

      cfg(app);
    } else if (filename === '.proxyrc') {
      if (typeof cfg !== 'object') {
        _logger.default.warn("Proxy table in '.proxyrc' should be of object type. Skipping...");

        return this;
      }

      for (const [context, options] of Object.entries(cfg)) {
        // each key is interpreted as context, and value as middleware options
        app.use((0, _httpProxyMiddleware.default)(context, options));
      }
    }

    return this;
  }

  async start() {
    const app = (0, _connect.default)();
    await this.applyProxyTable(app);
    app.use((req, res) => {
      this.logAccessIfVerbose(req);

      const response = () => this.respond(req, res); // Wait for the parcelInstance to finish bundling if needed


      if (this.pending) {
        this.once('bundled', response);
      } else {
        response();
      }
    });

    if (!this.options.https) {
      this.server = _http.default.createServer(app);
    } else if (typeof this.options.https === 'boolean') {
      this.server = _https.default.createServer((await (0, _utils.generateCertificate)(this.options.outputFS, this.options.cacheDir)), app);
    } else {
      this.server = _https.default.createServer((await (0, _utils.getCertificate)(this.options.inputFS, this.options.https)), app);
    }

    this.server.listen(this.options.port, this.options.host);
    return new Promise((resolve, reject) => {
      this.server.once('error', err => {
        _logger.default.error(new Error((0, _serverErrors.default)(err, this.options.port)));

        reject(err);
      });
      this.server.once('listening', () => {
        resolve(this.server);
      });
    });
  }

  stop() {
    return new Promise((resolve, reject) => {
      this.server.close(err => {
        if (err != null) {
          reject(err);
          return;
        }

        resolve();
      });
    });
  }

}

exports.default = Server;